{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"src/safe_simd/mc.rs","byte_start":6280,"byte_end":6286,"line_start":160,"line_end":160,"column_start":19,"column_end":25,"is_primary":true,"text":[{"text":"    let rnd_vec = unsafe { _mm256_set1_epi32(rnd) };","highlight_start":19,"highlight_end":25}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_unsafe)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unnecessary `unsafe` block\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/safe_simd/mc.rs:160:19\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m160\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let rnd_vec = unsafe { _mm256_set1_epi32(rnd) };\n    \u001b[1m\u001b[94m|\u001b[0m                   \u001b[1m\u001b[33m^^^^^^\u001b[0m \u001b[1m\u001b[33munnecessary `unsafe` block\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `#[warn(unused_unsafe)]` (part of `#[warn(unused)]`) on by default\n\n"}
{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"src/safe_simd/mc.rs","byte_start":6330,"byte_end":6336,"line_start":161,"line_end":161,"column_start":16,"column_end":22,"is_primary":true,"text":[{"text":"    let zero = unsafe { _mm256_setzero_si256() };","highlight_start":16,"highlight_end":22}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unnecessary `unsafe` block\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/safe_simd/mc.rs:161:16\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m161\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let zero = unsafe { _mm256_setzero_si256() };\n    \u001b[1m\u001b[94m|\u001b[0m                \u001b[1m\u001b[33m^^^^^^\u001b[0m \u001b[1m\u001b[33munnecessary `unsafe` block\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"src/safe_simd/mc.rs","byte_start":6383,"byte_end":6389,"line_start":162,"line_end":162,"column_start":19,"column_end":25,"is_primary":true,"text":[{"text":"    let max_vec = unsafe { _mm256_set1_epi32(max) };","highlight_start":19,"highlight_end":25}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unnecessary `unsafe` block\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/safe_simd/mc.rs:162:19\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m162\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let max_vec = unsafe { _mm256_set1_epi32(max) };\n    \u001b[1m\u001b[94m|\u001b[0m                   \u001b[1m\u001b[33m^^^^^^\u001b[0m \u001b[1m\u001b[33munnecessary `unsafe` block\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"src/safe_simd/mc.rs","byte_start":15687,"byte_end":15693,"line_start":417,"line_end":417,"column_start":19,"column_end":25,"is_primary":true,"text":[{"text":"    let rnd_vec = unsafe { _mm256_set1_epi32(rnd) };","highlight_start":19,"highlight_end":25}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unnecessary `unsafe` block\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/safe_simd/mc.rs:417:19\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m417\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let rnd_vec = unsafe { _mm256_set1_epi32(rnd) };\n    \u001b[1m\u001b[94m|\u001b[0m                   \u001b[1m\u001b[33m^^^^^^\u001b[0m \u001b[1m\u001b[33munnecessary `unsafe` block\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"src/safe_simd/mc.rs","byte_start":15737,"byte_end":15743,"line_start":418,"line_end":418,"column_start":16,"column_end":22,"is_primary":true,"text":[{"text":"    let zero = unsafe { _mm256_setzero_si256() };","highlight_start":16,"highlight_end":22}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unnecessary `unsafe` block\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/safe_simd/mc.rs:418:16\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m418\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let zero = unsafe { _mm256_setzero_si256() };\n    \u001b[1m\u001b[94m|\u001b[0m                \u001b[1m\u001b[33m^^^^^^\u001b[0m \u001b[1m\u001b[33munnecessary `unsafe` block\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"src/safe_simd/mc.rs","byte_start":15790,"byte_end":15796,"line_start":419,"line_end":419,"column_start":19,"column_end":25,"is_primary":true,"text":[{"text":"    let max_vec = unsafe { _mm256_set1_epi32(max) };","highlight_start":19,"highlight_end":25}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unnecessary `unsafe` block\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/safe_simd/mc.rs:419:19\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m419\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let max_vec = unsafe { _mm256_set1_epi32(max) };\n    \u001b[1m\u001b[94m|\u001b[0m                   \u001b[1m\u001b[33m^^^^^^\u001b[0m \u001b[1m\u001b[33munnecessary `unsafe` block\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"src/safe_simd/mc.rs","byte_start":15846,"byte_end":15852,"line_start":420,"line_end":420,"column_start":22,"column_end":28,"is_primary":true,"text":[{"text":"    let weight_vec = unsafe { _mm256_set1_epi32(weight) };","highlight_start":22,"highlight_end":28}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unnecessary `unsafe` block\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/safe_simd/mc.rs:420:22\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m420\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let weight_vec = unsafe { _mm256_set1_epi32(weight) };\n    \u001b[1m\u001b[94m|\u001b[0m                      \u001b[1m\u001b[33m^^^^^^\u001b[0m \u001b[1m\u001b[33munnecessary `unsafe` block\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"src/safe_simd/mc.rs","byte_start":15909,"byte_end":15915,"line_start":421,"line_end":421,"column_start":26,"column_end":32,"is_primary":true,"text":[{"text":"    let inv_weight_vec = unsafe { _mm256_set1_epi32(inv_weight) };","highlight_start":26,"highlight_end":32}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unnecessary `unsafe` block\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/safe_simd/mc.rs:421:26\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m421\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let inv_weight_vec = unsafe { _mm256_set1_epi32(inv_weight) };\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[33m^^^^^^\u001b[0m \u001b[1m\u001b[33munnecessary `unsafe` block\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"src/safe_simd/mc.rs","byte_start":20699,"byte_end":20705,"line_start":556,"line_end":556,"column_start":15,"column_end":21,"is_primary":true,"text":[{"text":"    let rnd = unsafe { _mm256_set1_epi32(512) };","highlight_start":15,"highlight_end":21}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unnecessary `unsafe` block\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/safe_simd/mc.rs:556:15\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m556\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let rnd = unsafe { _mm256_set1_epi32(512) };\n    \u001b[1m\u001b[94m|\u001b[0m               \u001b[1m\u001b[33m^^^^^^\u001b[0m \u001b[1m\u001b[33munnecessary `unsafe` block\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"src/safe_simd/mc.rs","byte_start":25165,"byte_end":25171,"line_start":664,"line_end":664,"column_start":19,"column_end":25,"is_primary":true,"text":[{"text":"    let rnd_vec = unsafe { _mm256_set1_epi32(rnd) };","highlight_start":19,"highlight_end":25}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unnecessary `unsafe` block\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/safe_simd/mc.rs:664:19\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m664\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let rnd_vec = unsafe { _mm256_set1_epi32(rnd) };\n    \u001b[1m\u001b[94m|\u001b[0m                   \u001b[1m\u001b[33m^^^^^^\u001b[0m \u001b[1m\u001b[33munnecessary `unsafe` block\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"src/safe_simd/mc.rs","byte_start":25215,"byte_end":25221,"line_start":665,"line_end":665,"column_start":16,"column_end":22,"is_primary":true,"text":[{"text":"    let zero = unsafe { _mm256_setzero_si256() };","highlight_start":16,"highlight_end":22}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unnecessary `unsafe` block\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/safe_simd/mc.rs:665:16\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m665\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let zero = unsafe { _mm256_setzero_si256() };\n    \u001b[1m\u001b[94m|\u001b[0m                \u001b[1m\u001b[33m^^^^^^\u001b[0m \u001b[1m\u001b[33munnecessary `unsafe` block\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"src/safe_simd/mc.rs","byte_start":25268,"byte_end":25274,"line_start":666,"line_end":666,"column_start":19,"column_end":25,"is_primary":true,"text":[{"text":"    let max_vec = unsafe { _mm256_set1_epi32(max) };","highlight_start":19,"highlight_end":25}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unnecessary `unsafe` block\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/safe_simd/mc.rs:666:19\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m666\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let max_vec = unsafe { _mm256_set1_epi32(max) };\n    \u001b[1m\u001b[94m|\u001b[0m                   \u001b[1m\u001b[33m^^^^^^\u001b[0m \u001b[1m\u001b[33munnecessary `unsafe` block\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"src/safe_simd/mc.rs","byte_start":25324,"byte_end":25330,"line_start":667,"line_end":667,"column_start":22,"column_end":28,"is_primary":true,"text":[{"text":"    let sixty_four = unsafe { _mm256_set1_epi32(64) };","highlight_start":22,"highlight_end":28}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unnecessary `unsafe` block\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/safe_simd/mc.rs:667:22\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m667\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let sixty_four = unsafe { _mm256_set1_epi32(64) };\n    \u001b[1m\u001b[94m|\u001b[0m                      \u001b[1m\u001b[33m^^^^^^\u001b[0m \u001b[1m\u001b[33munnecessary `unsafe` block\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"src/safe_simd/mc.rs","byte_start":30301,"byte_end":30307,"line_start":804,"line_end":804,"column_start":22,"column_end":28,"is_primary":true,"text":[{"text":"    let sixty_four = unsafe { _mm256_set1_epi16(64) };","highlight_start":22,"highlight_end":28}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unnecessary `unsafe` block\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/safe_simd/mc.rs:804:22\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m804\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let sixty_four = unsafe { _mm256_set1_epi16(64) };\n    \u001b[1m\u001b[94m|\u001b[0m                      \u001b[1m\u001b[33m^^^^^^\u001b[0m \u001b[1m\u001b[33munnecessary `unsafe` block\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"src/safe_simd/mc.rs","byte_start":30349,"byte_end":30355,"line_start":805,"line_end":805,"column_start":15,"column_end":21,"is_primary":true,"text":[{"text":"    let rnd = unsafe { _mm256_set1_epi16(32) };","highlight_start":15,"highlight_end":21}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unnecessary `unsafe` block\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/safe_simd/mc.rs:805:15\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m805\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let rnd = unsafe { _mm256_set1_epi16(32) };\n    \u001b[1m\u001b[94m|\u001b[0m               \u001b[1m\u001b[33m^^^^^^\u001b[0m \u001b[1m\u001b[33munnecessary `unsafe` block\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"src/safe_simd/mc.rs","byte_start":33377,"byte_end":33383,"line_start":887,"line_end":887,"column_start":15,"column_end":21,"is_primary":true,"text":[{"text":"    let rnd = unsafe { _mm256_set1_epi32(32) };","highlight_start":15,"highlight_end":21}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unnecessary `unsafe` block\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/safe_simd/mc.rs:887:15\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m887\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let rnd = unsafe { _mm256_set1_epi32(32) };\n    \u001b[1m\u001b[94m|\u001b[0m               \u001b[1m\u001b[33m^^^^^^\u001b[0m \u001b[1m\u001b[33munnecessary `unsafe` block\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"src/safe_simd/mc.rs","byte_start":33432,"byte_end":33438,"line_start":888,"line_end":888,"column_start":22,"column_end":28,"is_primary":true,"text":[{"text":"    let sixty_four = unsafe { _mm256_set1_epi32(64) };","highlight_start":22,"highlight_end":28}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unnecessary `unsafe` block\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/safe_simd/mc.rs:888:22\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m888\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let sixty_four = unsafe { _mm256_set1_epi32(64) };\n    \u001b[1m\u001b[94m|\u001b[0m                      \u001b[1m\u001b[33m^^^^^^\u001b[0m \u001b[1m\u001b[33munnecessary `unsafe` block\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"src/safe_simd/mc.rs","byte_start":36812,"byte_end":36818,"line_start":977,"line_end":977,"column_start":15,"column_end":21,"is_primary":true,"text":[{"text":"    let rnd = unsafe { _mm256_set1_epi16(32) };","highlight_start":15,"highlight_end":21}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unnecessary `unsafe` block\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/safe_simd/mc.rs:977:15\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m977\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let rnd = unsafe { _mm256_set1_epi16(32) };\n    \u001b[1m\u001b[94m|\u001b[0m               \u001b[1m\u001b[33m^^^^^^\u001b[0m \u001b[1m\u001b[33munnecessary `unsafe` block\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"src/safe_simd/mc.rs","byte_start":36867,"byte_end":36873,"line_start":978,"line_end":978,"column_start":22,"column_end":28,"is_primary":true,"text":[{"text":"    let sixty_four = unsafe { _mm256_set1_epi16(64) };","highlight_start":22,"highlight_end":28}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unnecessary `unsafe` block\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/safe_simd/mc.rs:978:22\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m978\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let sixty_four = unsafe { _mm256_set1_epi16(64) };\n    \u001b[1m\u001b[94m|\u001b[0m                      \u001b[1m\u001b[33m^^^^^^\u001b[0m \u001b[1m\u001b[33munnecessary `unsafe` block\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"src/safe_simd/mc.rs","byte_start":37244,"byte_end":37250,"line_start":988,"line_end":988,"column_start":23,"column_end":29,"is_primary":true,"text":[{"text":"        let mask_16 = unsafe { _mm256_set1_epi16(m as i16) };","highlight_start":23,"highlight_end":29}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unnecessary `unsafe` block\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/safe_simd/mc.rs:988:23\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m988\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let mask_16 = unsafe { _mm256_set1_epi16(m as i16) };\n    \u001b[1m\u001b[94m|\u001b[0m                       \u001b[1m\u001b[33m^^^^^^\u001b[0m \u001b[1m\u001b[33munnecessary `unsafe` block\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"src/safe_simd/mc.rs","byte_start":37307,"byte_end":37313,"line_start":989,"line_end":989,"column_start":24,"column_end":30,"is_primary":true,"text":[{"text":"        let inv_mask = unsafe { _mm256_sub_epi16(sixty_four, mask_16) };","highlight_start":24,"highlight_end":30}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unnecessary `unsafe` block\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/safe_simd/mc.rs:989:24\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m989\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let inv_mask = unsafe { _mm256_sub_epi16(sixty_four, mask_16) };\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[33m^^^^^^\u001b[0m \u001b[1m\u001b[33munnecessary `unsafe` block\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"src/safe_simd/mc.rs","byte_start":39424,"byte_end":39430,"line_start":1051,"line_end":1051,"column_start":15,"column_end":21,"is_primary":true,"text":[{"text":"    let rnd = unsafe { _mm256_set1_epi16(32) };","highlight_start":15,"highlight_end":21}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unnecessary `unsafe` block\u001b[0m\n    \u001b[1m\u001b[94m--> \u001b[0msrc/safe_simd/mc.rs:1051:15\n     \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m1051\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let rnd = unsafe { _mm256_set1_epi16(32) };\n     \u001b[1m\u001b[94m|\u001b[0m               \u001b[1m\u001b[33m^^^^^^\u001b[0m \u001b[1m\u001b[33munnecessary `unsafe` block\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"src/safe_simd/mc.rs","byte_start":39479,"byte_end":39485,"line_start":1052,"line_end":1052,"column_start":22,"column_end":28,"is_primary":true,"text":[{"text":"    let sixty_four = unsafe { _mm256_set1_epi16(64) };","highlight_start":22,"highlight_end":28}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unnecessary `unsafe` block\u001b[0m\n    \u001b[1m\u001b[94m--> \u001b[0msrc/safe_simd/mc.rs:1052:22\n     \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m1052\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let sixty_four = unsafe { _mm256_set1_epi16(64) };\n     \u001b[1m\u001b[94m|\u001b[0m                      \u001b[1m\u001b[33m^^^^^^\u001b[0m \u001b[1m\u001b[33munnecessary `unsafe` block\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"src/safe_simd/mc.rs","byte_start":42148,"byte_end":42154,"line_start":1126,"line_end":1126,"column_start":15,"column_end":21,"is_primary":true,"text":[{"text":"    let rnd = unsafe { _mm256_set1_epi32(32) };","highlight_start":15,"highlight_end":21}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unnecessary `unsafe` block\u001b[0m\n    \u001b[1m\u001b[94m--> \u001b[0msrc/safe_simd/mc.rs:1126:15\n     \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m1126\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let rnd = unsafe { _mm256_set1_epi32(32) };\n     \u001b[1m\u001b[94m|\u001b[0m               \u001b[1m\u001b[33m^^^^^^\u001b[0m \u001b[1m\u001b[33munnecessary `unsafe` block\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"src/safe_simd/mc.rs","byte_start":42203,"byte_end":42209,"line_start":1127,"line_end":1127,"column_start":22,"column_end":28,"is_primary":true,"text":[{"text":"    let sixty_four = unsafe { _mm256_set1_epi32(64) };","highlight_start":22,"highlight_end":28}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unnecessary `unsafe` block\u001b[0m\n    \u001b[1m\u001b[94m--> \u001b[0msrc/safe_simd/mc.rs:1127:22\n     \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m1127\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let sixty_four = unsafe { _mm256_set1_epi32(64) };\n     \u001b[1m\u001b[94m|\u001b[0m                      \u001b[1m\u001b[33m^^^^^^\u001b[0m \u001b[1m\u001b[33munnecessary `unsafe` block\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"src/safe_simd/mc.rs","byte_start":42538,"byte_end":42544,"line_start":1136,"line_end":1136,"column_start":23,"column_end":29,"is_primary":true,"text":[{"text":"        let mask_32 = unsafe { _mm256_set1_epi32(m as i32) };","highlight_start":23,"highlight_end":29}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unnecessary `unsafe` block\u001b[0m\n    \u001b[1m\u001b[94m--> \u001b[0msrc/safe_simd/mc.rs:1136:23\n     \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m1136\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let mask_32 = unsafe { _mm256_set1_epi32(m as i32) };\n     \u001b[1m\u001b[94m|\u001b[0m                       \u001b[1m\u001b[33m^^^^^^\u001b[0m \u001b[1m\u001b[33munnecessary `unsafe` block\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"src/safe_simd/mc.rs","byte_start":42601,"byte_end":42607,"line_start":1137,"line_end":1137,"column_start":24,"column_end":30,"is_primary":true,"text":[{"text":"        let inv_mask = unsafe { _mm256_sub_epi32(sixty_four, mask_32) };","highlight_start":24,"highlight_end":30}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unnecessary `unsafe` block\u001b[0m\n    \u001b[1m\u001b[94m--> \u001b[0msrc/safe_simd/mc.rs:1137:24\n     \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m1137\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let inv_mask = unsafe { _mm256_sub_epi32(sixty_four, mask_32) };\n     \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[33m^^^^^^\u001b[0m \u001b[1m\u001b[33munnecessary `unsafe` block\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"src/safe_simd/mc.rs","byte_start":45015,"byte_end":45021,"line_start":1204,"line_end":1204,"column_start":15,"column_end":21,"is_primary":true,"text":[{"text":"    let rnd = unsafe { _mm256_set1_epi32(32) };","highlight_start":15,"highlight_end":21}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unnecessary `unsafe` block\u001b[0m\n    \u001b[1m\u001b[94m--> \u001b[0msrc/safe_simd/mc.rs:1204:15\n     \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m1204\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let rnd = unsafe { _mm256_set1_epi32(32) };\n     \u001b[1m\u001b[94m|\u001b[0m               \u001b[1m\u001b[33m^^^^^^\u001b[0m \u001b[1m\u001b[33munnecessary `unsafe` block\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"src/safe_simd/mc.rs","byte_start":45070,"byte_end":45076,"line_start":1205,"line_end":1205,"column_start":22,"column_end":28,"is_primary":true,"text":[{"text":"    let sixty_four = unsafe { _mm256_set1_epi32(64) };","highlight_start":22,"highlight_end":28}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unnecessary `unsafe` block\u001b[0m\n    \u001b[1m\u001b[94m--> \u001b[0msrc/safe_simd/mc.rs:1205:22\n     \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m1205\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let sixty_four = unsafe { _mm256_set1_epi32(64) };\n     \u001b[1m\u001b[94m|\u001b[0m                      \u001b[1m\u001b[33m^^^^^^\u001b[0m \u001b[1m\u001b[33munnecessary `unsafe` block\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"struct `Rav1dFrameContextTaskThreadPendingTasks` is never constructed","code":{"code":"dead_code","explanation":null},"level":"warning","spans":[{"file_name":"src/internal.rs","byte_start":23634,"byte_end":23673,"line_start":719,"line_end":719,"column_start":12,"column_end":51,"is_primary":true,"text":[{"text":"pub struct Rav1dFrameContextTaskThreadPendingTasks {","highlight_start":12,"highlight_end":51}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: struct `Rav1dFrameContextTaskThreadPendingTasks` is never constructed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/internal.rs:719:12\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m719\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Rav1dFrameContextTaskThreadPendingTasks {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default\n\n"}
{"$message_type":"diagnostic","message":"constant `MID_STRIDE` is never used","code":{"code":"dead_code","explanation":null},"level":"warning","spans":[{"file_name":"src/safe_simd/mc.rs","byte_start":47600,"byte_end":47610,"line_start":1268,"line_end":1268,"column_start":7,"column_end":17,"is_primary":true,"text":[{"text":"const MID_STRIDE: usize = 128;","highlight_start":7,"highlight_end":17}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: constant `MID_STRIDE` is never used\u001b[0m\n    \u001b[1m\u001b[94m--> \u001b[0msrc/safe_simd/mc.rs:1268:7\n     \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m1268\u001b[0m \u001b[1m\u001b[94m|\u001b[0m const MID_STRIDE: usize = 128;\n     \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[33m^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"function `get_filter` is never used","code":{"code":"dead_code","explanation":null},"level":"warning","spans":[{"file_name":"src/safe_simd/mc.rs","byte_start":47713,"byte_end":47723,"line_start":1272,"line_end":1272,"column_start":4,"column_end":14,"is_primary":true,"text":[{"text":"fn get_filter(m: usize, d: usize, filter_idx: usize) -> Option<&'static [i8; 8]> {","highlight_start":4,"highlight_end":14}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: function `get_filter` is never used\u001b[0m\n    \u001b[1m\u001b[94m--> \u001b[0msrc/safe_simd/mc.rs:1272:4\n     \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m1272\u001b[0m \u001b[1m\u001b[94m|\u001b[0m fn get_filter(m: usize, d: usize, filter_idx: usize) -> Option<&'static [i8; 8]> {\n     \u001b[1m\u001b[94m|\u001b[0m    \u001b[1m\u001b[33m^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"function `h_filter_8tap_8bpc_avx2` is never used","code":{"code":"dead_code","explanation":null},"level":"warning","spans":[{"file_name":"src/safe_simd/mc.rs","byte_start":48271,"byte_end":48294,"line_start":1288,"line_end":1288,"column_start":11,"column_end":34,"is_primary":true,"text":[{"text":"unsafe fn h_filter_8tap_8bpc_avx2(","highlight_start":11,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: function `h_filter_8tap_8bpc_avx2` is never used\u001b[0m\n    \u001b[1m\u001b[94m--> \u001b[0msrc/safe_simd/mc.rs:1288:11\n     \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m1288\u001b[0m \u001b[1m\u001b[94m|\u001b[0m unsafe fn h_filter_8tap_8bpc_avx2(\n     \u001b[1m\u001b[94m|\u001b[0m           \u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"function `v_filter_8tap_8bpc_avx2` is never used","code":{"code":"dead_code","explanation":null},"level":"warning","spans":[{"file_name":"src/safe_simd/mc.rs","byte_start":52495,"byte_end":52518,"line_start":1389,"line_end":1389,"column_start":11,"column_end":34,"is_primary":true,"text":[{"text":"unsafe fn v_filter_8tap_8bpc_avx2(","highlight_start":11,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: function `v_filter_8tap_8bpc_avx2` is never used\u001b[0m\n    \u001b[1m\u001b[94m--> \u001b[0msrc/safe_simd/mc.rs:1389:11\n     \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m1389\u001b[0m \u001b[1m\u001b[94m|\u001b[0m unsafe fn v_filter_8tap_8bpc_avx2(\n     \u001b[1m\u001b[94m|\u001b[0m           \u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"hiding a lifetime that's elided elsewhere is confusing","code":{"code":"mismatched_lifetime_syntaxes","explanation":null},"level":"warning","spans":[{"file_name":"include/dav1d/picture.rs","byte_start":9562,"byte_end":9567,"line_start":262,"line_end":262,"column_start":38,"column_end":43,"is_primary":true,"text":[{"text":"    pub fn with_offset<BD: BitDepth>(&self) -> Rav1dPictureDataComponentOffset {","highlight_start":38,"highlight_end":43}],"label":"the lifetime is elided here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"include/dav1d/picture.rs","byte_start":9572,"byte_end":9603,"line_start":262,"line_end":262,"column_start":48,"column_end":79,"is_primary":true,"text":[{"text":"    pub fn with_offset<BD: BitDepth>(&self) -> Rav1dPictureDataComponentOffset {","highlight_start":48,"highlight_end":79}],"label":"the same lifetime is hidden here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the same lifetime is referred to in inconsistent ways, making the signature confusing","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`#[warn(mismatched_lifetime_syntaxes)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"use `'_` for type paths","code":null,"level":"help","spans":[{"file_name":"include/dav1d/picture.rs","byte_start":9603,"byte_end":9603,"line_start":262,"line_end":262,"column_start":79,"column_end":79,"is_primary":true,"text":[{"text":"    pub fn with_offset<BD: BitDepth>(&self) -> Rav1dPictureDataComponentOffset {","highlight_start":79,"highlight_end":79}],"label":null,"suggested_replacement":"<'_>","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"consistently use `'_`","code":null,"level":"help","spans":[{"file_name":"include/dav1d/picture.rs","byte_start":9563,"byte_end":9563,"line_start":262,"line_end":262,"column_start":39,"column_end":39,"is_primary":true,"text":[{"text":"    pub fn with_offset<BD: BitDepth>(&self) -> Rav1dPictureDataComponentOffset {","highlight_start":39,"highlight_end":39}],"label":null,"suggested_replacement":"'_ ","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"include/dav1d/picture.rs","byte_start":9603,"byte_end":9603,"line_start":262,"line_end":262,"column_start":79,"column_end":79,"is_primary":true,"text":[{"text":"    pub fn with_offset<BD: BitDepth>(&self) -> Rav1dPictureDataComponentOffset {","highlight_start":79,"highlight_end":79}],"label":null,"suggested_replacement":"<'_>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: hiding a lifetime that's elided elsewhere is confusing\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0minclude/dav1d/picture.rs:262:38\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m262\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn with_offset<BD: BitDepth>(&self) -> Rav1dPictureDataComponentOffset {\n    \u001b[1m\u001b[94m|\u001b[0m                                      \u001b[1m\u001b[33m^^^^^\u001b[0m     \u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[33mthe same lifetime is hidden here\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                                      \u001b[1m\u001b[33m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                                      \u001b[1m\u001b[33mthe lifetime is elided here\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the same lifetime is referred to in inconsistent ways, making the signature confusing\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `#[warn(mismatched_lifetime_syntaxes)]` on by default\n\u001b[1m\u001b[96mhelp\u001b[0m: use `'_` for type paths\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m262\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    pub fn with_offset<BD: BitDepth>(&self) -> Rav1dPictureDataComponentOffset\u001b[92m<'_>\u001b[0m {\n    \u001b[1m\u001b[94m|\u001b[0m                                                                               \u001b[92m++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"hiding a lifetime that's elided elsewhere is confusing","code":{"code":"mismatched_lifetime_syntaxes","explanation":null},"level":"warning","spans":[{"file_name":"include/dav1d/picture.rs","byte_start":19298,"byte_end":19303,"line_start":533,"line_end":533,"column_start":37,"column_end":42,"is_primary":true,"text":[{"text":"    pub fn lf_offsets<BD: BitDepth>(&self, y: c_int) -> [Rav1dPictureDataComponentOffset; 3] {","highlight_start":37,"highlight_end":42}],"label":"the lifetime is elided here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"include/dav1d/picture.rs","byte_start":19319,"byte_end":19350,"line_start":533,"line_end":533,"column_start":58,"column_end":89,"is_primary":true,"text":[{"text":"    pub fn lf_offsets<BD: BitDepth>(&self, y: c_int) -> [Rav1dPictureDataComponentOffset; 3] {","highlight_start":58,"highlight_end":89}],"label":"the same lifetime is hidden here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the same lifetime is referred to in inconsistent ways, making the signature confusing","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"use `'_` for type paths","code":null,"level":"help","spans":[{"file_name":"include/dav1d/picture.rs","byte_start":19350,"byte_end":19350,"line_start":533,"line_end":533,"column_start":89,"column_end":89,"is_primary":true,"text":[{"text":"    pub fn lf_offsets<BD: BitDepth>(&self, y: c_int) -> [Rav1dPictureDataComponentOffset; 3] {","highlight_start":89,"highlight_end":89}],"label":null,"suggested_replacement":"<'_>","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"consistently use `'_`","code":null,"level":"help","spans":[{"file_name":"include/dav1d/picture.rs","byte_start":19299,"byte_end":19299,"line_start":533,"line_end":533,"column_start":38,"column_end":38,"is_primary":true,"text":[{"text":"    pub fn lf_offsets<BD: BitDepth>(&self, y: c_int) -> [Rav1dPictureDataComponentOffset; 3] {","highlight_start":38,"highlight_end":38}],"label":null,"suggested_replacement":"'_ ","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"include/dav1d/picture.rs","byte_start":19350,"byte_end":19350,"line_start":533,"line_end":533,"column_start":89,"column_end":89,"is_primary":true,"text":[{"text":"    pub fn lf_offsets<BD: BitDepth>(&self, y: c_int) -> [Rav1dPictureDataComponentOffset; 3] {","highlight_start":89,"highlight_end":89}],"label":null,"suggested_replacement":"<'_>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: hiding a lifetime that's elided elsewhere is confusing\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0minclude/dav1d/picture.rs:533:37\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m533\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn lf_offsets<BD: BitDepth>(&self, y: c_int) -> [Rav1dPictureDataComponentOffset; 3] {\n    \u001b[1m\u001b[94m|\u001b[0m                                     \u001b[1m\u001b[33m^^^^^\u001b[0m                \u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[33mthe same lifetime is hidden here\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                                     \u001b[1m\u001b[33m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                                     \u001b[1m\u001b[33mthe lifetime is elided here\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the same lifetime is referred to in inconsistent ways, making the signature confusing\n\u001b[1m\u001b[96mhelp\u001b[0m: use `'_` for type paths\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m533\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    pub fn lf_offsets<BD: BitDepth>(&self, y: c_int) -> [Rav1dPictureDataComponentOffset\u001b[92m<'_>\u001b[0m; 3] {\n    \u001b[1m\u001b[94m|\u001b[0m                                                                                         \u001b[92m++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"function pointer comparisons do not produce meaningful results since their addresses are not guaranteed to be unique","code":{"code":"unpredictable_function_pointer_comparisons","explanation":null},"level":"warning","spans":[{"file_name":"src/wrap_fn_ptr.rs","byte_start":2500,"byte_end":2505,"line_start":58,"line_end":58,"column_start":27,"column_end":32,"is_primary":true,"text":[{"text":"            pub struct Fn(FnPtr);","highlight_start":27,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/wrap_fn_ptr.rs","byte_start":2425,"byte_end":2434,"line_start":56,"line_end":56,"column_start":35,"column_end":44,"is_primary":false,"text":[{"text":"            #[derive(Clone, Copy, PartialEq, Eq)]","highlight_start":35,"highlight_end":44}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/cdef.rs","byte_start":1391,"byte_end":1878,"line_start":46,"line_end":61,"column_start":1,"column_end":9,"is_primary":false,"text":[{"text":"wrap_fn_ptr!(pub unsafe extern \"C\" fn cdef(","highlight_start":1,"highlight_end":44},{"text":"    dst_ptr: *mut DynPixel,","highlight_start":1,"highlight_end":28},{"text":"    stride: ptrdiff_t,","highlight_start":1,"highlight_end":23},{"text":"    left: *const [LeftPixelRow2px<DynPixel>; 8],","highlight_start":1,"highlight_end":49},{"text":"    top_ptr: *const DynPixel,","highlight_start":1,"highlight_end":30},{"text":"    bottom_ptr: *const DynPixel,","highlight_start":1,"highlight_end":33},{"text":"    pri_strength: c_int,","highlight_start":1,"highlight_end":25},{"text":"    sec_strength: c_int,","highlight_start":1,"highlight_end":25},{"text":"    dir: c_int,","highlight_start":1,"highlight_end":16},{"text":"    damping: c_int,","highlight_start":1,"highlight_end":20},{"text":"    edges: CdefEdgeFlags,","highlight_start":1,"highlight_end":26},{"text":"    bitdepth_max: c_int,","highlight_start":1,"highlight_end":25},{"text":"    _dst: *const FFISafe<Rav1dPictureDataComponentOffset>,","highlight_start":1,"highlight_end":59},{"text":"    _top: *const FFISafe<CdefTop>,","highlight_start":1,"highlight_end":35},{"text":"    _bottom: *const FFISafe<CdefBottom>,","highlight_start":1,"highlight_end":41},{"text":") -> ());","highlight_start":1,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"wrap_fn_ptr!","def_site_span":{"file_name":"src/wrap_fn_ptr.rs","byte_start":1818,"byte_end":1842,"line_start":41,"line_end":41,"column_start":1,"column_end":25,"is_primary":false,"text":[{"text":"macro_rules! wrap_fn_ptr {","highlight_start":1,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"#[derive(PartialEq)]","def_site_span":{"file_name":"/rustc/f60a0f1bcc5a2a6dd8eb2d2021da79b40f5fbae9/library/core/src/cmp.rs","byte_start":10192,"byte_end":10211,"line_start":274,"line_end":274,"column_start":1,"column_end":20,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the address of the same function can vary between different codegen units","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"furthermore, different functions could have the same address after being merged together","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more information visit <https://doc.rust-lang.org/nightly/core/ptr/fn.fn_addr_eq.html>","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"`#[warn(unpredictable_function_pointer_comparisons)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: function pointer comparisons do not produce meaningful results since their addresses are not guaranteed to be unique\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/wrap_fn_ptr.rs:58:27\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m58\u001b[0m \u001b[1m\u001b[94m|\u001b[0m               pub struct Fn(FnPtr);\n   \u001b[1m\u001b[94m|\u001b[0m                             \u001b[1m\u001b[33m^^^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m::: \u001b[0msrc/cdef.rs:46:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m46\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m wrap_fn_ptr!(pub unsafe extern \"C\" fn cdef(\n\u001b[1m\u001b[94m47\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     dst_ptr: *mut DynPixel,\n\u001b[1m\u001b[94m48\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     stride: ptrdiff_t,\n\u001b[1m\u001b[94m49\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     left: *const [LeftPixelRow2px<DynPixel>; 8],\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m60\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     _bottom: *const FFISafe<CdefBottom>,\n\u001b[1m\u001b[94m61\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m ) -> ());\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|________-\u001b[0m \u001b[1m\u001b[94min this macro invocation\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the address of the same function can vary between different codegen units\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: furthermore, different functions could have the same address after being merged together\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for more information visit <https://doc.rust-lang.org/nightly/core/ptr/fn.fn_addr_eq.html>\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `#[warn(unpredictable_function_pointer_comparisons)]` on by default\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this warning originates in the derive macro `PartialEq` which comes from the expansion of the macro `wrap_fn_ptr` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"function pointer comparisons do not produce meaningful results since their addresses are not guaranteed to be unique","code":{"code":"unpredictable_function_pointer_comparisons","explanation":null},"level":"warning","spans":[{"file_name":"src/wrap_fn_ptr.rs","byte_start":2500,"byte_end":2505,"line_start":58,"line_end":58,"column_start":27,"column_end":32,"is_primary":true,"text":[{"text":"            pub struct Fn(FnPtr);","highlight_start":27,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/wrap_fn_ptr.rs","byte_start":2425,"byte_end":2434,"line_start":56,"line_end":56,"column_start":35,"column_end":44,"is_primary":false,"text":[{"text":"            #[derive(Clone, Copy, PartialEq, Eq)]","highlight_start":35,"highlight_end":44}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/cdef.rs","byte_start":3659,"byte_end":3886,"line_start":118,"line_end":124,"column_start":1,"column_end":12,"is_primary":false,"text":[{"text":"wrap_fn_ptr!(pub unsafe extern \"C\" fn cdef_dir(","highlight_start":1,"highlight_end":48},{"text":"    dst_ptr: *const DynPixel,","highlight_start":1,"highlight_end":30},{"text":"    dst_stride: ptrdiff_t,","highlight_start":1,"highlight_end":27},{"text":"    variance: &mut c_uint,","highlight_start":1,"highlight_end":27},{"text":"    bitdepth_max: c_int,","highlight_start":1,"highlight_end":25},{"text":"    _dst: *const FFISafe<Rav1dPictureDataComponentOffset>,","highlight_start":1,"highlight_end":59},{"text":") -> c_int);","highlight_start":1,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"wrap_fn_ptr!","def_site_span":{"file_name":"src/wrap_fn_ptr.rs","byte_start":1818,"byte_end":1842,"line_start":41,"line_end":41,"column_start":1,"column_end":25,"is_primary":false,"text":[{"text":"macro_rules! wrap_fn_ptr {","highlight_start":1,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"#[derive(PartialEq)]","def_site_span":{"file_name":"/rustc/f60a0f1bcc5a2a6dd8eb2d2021da79b40f5fbae9/library/core/src/cmp.rs","byte_start":10192,"byte_end":10211,"line_start":274,"line_end":274,"column_start":1,"column_end":20,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the address of the same function can vary between different codegen units","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"furthermore, different functions could have the same address after being merged together","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more information visit <https://doc.rust-lang.org/nightly/core/ptr/fn.fn_addr_eq.html>","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: function pointer comparisons do not produce meaningful results since their addresses are not guaranteed to be unique\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/wrap_fn_ptr.rs:58:27\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 58\u001b[0m \u001b[1m\u001b[94m|\u001b[0m               pub struct Fn(FnPtr);\n    \u001b[1m\u001b[94m|\u001b[0m                             \u001b[1m\u001b[33m^^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/cdef.rs:118:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m118\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m wrap_fn_ptr!(pub unsafe extern \"C\" fn cdef_dir(\n\u001b[1m\u001b[94m119\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     dst_ptr: *const DynPixel,\n\u001b[1m\u001b[94m120\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     dst_stride: ptrdiff_t,\n\u001b[1m\u001b[94m121\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     variance: &mut c_uint,\n\u001b[1m\u001b[94m122\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     bitdepth_max: c_int,\n\u001b[1m\u001b[94m123\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     _dst: *const FFISafe<Rav1dPictureDataComponentOffset>,\n\u001b[1m\u001b[94m124\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m ) -> c_int);\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|___________-\u001b[0m \u001b[1m\u001b[94min this macro invocation\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the address of the same function can vary between different codegen units\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: furthermore, different functions could have the same address after being merged together\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for more information visit <https://doc.rust-lang.org/nightly/core/ptr/fn.fn_addr_eq.html>\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this warning originates in the derive macro `PartialEq` which comes from the expansion of the macro `wrap_fn_ptr` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"hiding a lifetime that's elided elsewhere is confusing","code":{"code":"mismatched_lifetime_syntaxes","explanation":null},"level":"warning","spans":[{"file_name":"src/cdf.rs","byte_start":5407,"byte_end":5412,"line_start":156,"line_end":156,"column_start":22,"column_end":27,"is_primary":true,"text":[{"text":"    pub fn cdf_write(&self) -> RwLockWriteGuard<CdfContext> {","highlight_start":22,"highlight_end":27}],"label":"the lifetime is elided here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/cdf.rs","byte_start":5417,"byte_end":5445,"line_start":156,"line_end":156,"column_start":32,"column_end":60,"is_primary":true,"text":[{"text":"    pub fn cdf_write(&self) -> RwLockWriteGuard<CdfContext> {","highlight_start":32,"highlight_end":60}],"label":"the same lifetime is hidden here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the same lifetime is referred to in inconsistent ways, making the signature confusing","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"use `'_` for type paths","code":null,"level":"help","spans":[{"file_name":"src/cdf.rs","byte_start":5434,"byte_end":5434,"line_start":156,"line_end":156,"column_start":49,"column_end":49,"is_primary":true,"text":[{"text":"    pub fn cdf_write(&self) -> RwLockWriteGuard<CdfContext> {","highlight_start":49,"highlight_end":49}],"label":null,"suggested_replacement":"'_, ","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"consistently use `'_`","code":null,"level":"help","spans":[{"file_name":"src/cdf.rs","byte_start":5408,"byte_end":5408,"line_start":156,"line_end":156,"column_start":23,"column_end":23,"is_primary":true,"text":[{"text":"    pub fn cdf_write(&self) -> RwLockWriteGuard<CdfContext> {","highlight_start":23,"highlight_end":23}],"label":null,"suggested_replacement":"'_ ","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/cdf.rs","byte_start":5434,"byte_end":5434,"line_start":156,"line_end":156,"column_start":49,"column_end":49,"is_primary":true,"text":[{"text":"    pub fn cdf_write(&self) -> RwLockWriteGuard<CdfContext> {","highlight_start":49,"highlight_end":49}],"label":null,"suggested_replacement":"'_, ","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: hiding a lifetime that's elided elsewhere is confusing\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/cdf.rs:156:22\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m156\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn cdf_write(&self) -> RwLockWriteGuard<CdfContext> {\n    \u001b[1m\u001b[94m|\u001b[0m                      \u001b[1m\u001b[33m^^^^^\u001b[0m     \u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[33mthe same lifetime is hidden here\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                      \u001b[1m\u001b[33m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                      \u001b[1m\u001b[33mthe lifetime is elided here\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the same lifetime is referred to in inconsistent ways, making the signature confusing\n\u001b[1m\u001b[96mhelp\u001b[0m: use `'_` for type paths\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m156\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    pub fn cdf_write(&self) -> RwLockWriteGuard<\u001b[92m'_, \u001b[0mCdfContext> {\n    \u001b[1m\u001b[94m|\u001b[0m                                                 \u001b[92m+++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"function pointer comparisons do not produce meaningful results since their addresses are not guaranteed to be unique","code":{"code":"unpredictable_function_pointer_comparisons","explanation":null},"level":"warning","spans":[{"file_name":"src/wrap_fn_ptr.rs","byte_start":2500,"byte_end":2505,"line_start":58,"line_end":58,"column_start":27,"column_end":32,"is_primary":true,"text":[{"text":"            pub struct Fn(FnPtr);","highlight_start":27,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/wrap_fn_ptr.rs","byte_start":2425,"byte_end":2434,"line_start":56,"line_end":56,"column_start":35,"column_end":44,"is_primary":false,"text":[{"text":"            #[derive(Clone, Copy, PartialEq, Eq)]","highlight_start":35,"highlight_end":44}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/filmgrain.rs","byte_start":1539,"byte_end":1693,"line_start":50,"line_end":54,"column_start":1,"column_end":9,"is_primary":false,"text":[{"text":"wrap_fn_ptr!(pub unsafe extern \"C\" fn generate_grain_y(","highlight_start":1,"highlight_end":56},{"text":"    buf: *mut GrainLut<DynEntry>,","highlight_start":1,"highlight_end":34},{"text":"    data: &Dav1dFilmGrainData,","highlight_start":1,"highlight_end":31},{"text":"    bitdepth_max: c_int,","highlight_start":1,"highlight_end":25},{"text":") -> ());","highlight_start":1,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"wrap_fn_ptr!","def_site_span":{"file_name":"src/wrap_fn_ptr.rs","byte_start":1818,"byte_end":1842,"line_start":41,"line_end":41,"column_start":1,"column_end":25,"is_primary":false,"text":[{"text":"macro_rules! wrap_fn_ptr {","highlight_start":1,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"#[derive(PartialEq)]","def_site_span":{"file_name":"/rustc/f60a0f1bcc5a2a6dd8eb2d2021da79b40f5fbae9/library/core/src/cmp.rs","byte_start":10192,"byte_end":10211,"line_start":274,"line_end":274,"column_start":1,"column_end":20,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the address of the same function can vary between different codegen units","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"furthermore, different functions could have the same address after being merged together","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more information visit <https://doc.rust-lang.org/nightly/core/ptr/fn.fn_addr_eq.html>","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: function pointer comparisons do not produce meaningful results since their addresses are not guaranteed to be unique\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/wrap_fn_ptr.rs:58:27\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m58\u001b[0m \u001b[1m\u001b[94m|\u001b[0m               pub struct Fn(FnPtr);\n   \u001b[1m\u001b[94m|\u001b[0m                             \u001b[1m\u001b[33m^^^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m::: \u001b[0msrc/filmgrain.rs:50:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m50\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m wrap_fn_ptr!(pub unsafe extern \"C\" fn generate_grain_y(\n\u001b[1m\u001b[94m51\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     buf: *mut GrainLut<DynEntry>,\n\u001b[1m\u001b[94m52\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     data: &Dav1dFilmGrainData,\n\u001b[1m\u001b[94m53\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     bitdepth_max: c_int,\n\u001b[1m\u001b[94m54\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m ) -> ());\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|________-\u001b[0m \u001b[1m\u001b[94min this macro invocation\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the address of the same function can vary between different codegen units\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: furthermore, different functions could have the same address after being merged together\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for more information visit <https://doc.rust-lang.org/nightly/core/ptr/fn.fn_addr_eq.html>\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this warning originates in the derive macro `PartialEq` which comes from the expansion of the macro `wrap_fn_ptr` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"function pointer comparisons do not produce meaningful results since their addresses are not guaranteed to be unique","code":{"code":"unpredictable_function_pointer_comparisons","explanation":null},"level":"warning","spans":[{"file_name":"src/wrap_fn_ptr.rs","byte_start":2500,"byte_end":2505,"line_start":58,"line_end":58,"column_start":27,"column_end":32,"is_primary":true,"text":[{"text":"            pub struct Fn(FnPtr);","highlight_start":27,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/wrap_fn_ptr.rs","byte_start":2425,"byte_end":2434,"line_start":56,"line_end":56,"column_start":35,"column_end":44,"is_primary":false,"text":[{"text":"            #[derive(Clone, Copy, PartialEq, Eq)]","highlight_start":35,"highlight_end":44}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/filmgrain.rs","byte_start":2134,"byte_end":2345,"line_start":71,"line_end":77,"column_start":1,"column_end":9,"is_primary":false,"text":[{"text":"wrap_fn_ptr!(pub unsafe extern \"C\" fn generate_grain_uv(","highlight_start":1,"highlight_end":57},{"text":"    buf: *mut GrainLut<DynEntry>,","highlight_start":1,"highlight_end":34},{"text":"    buf_y: *const GrainLut<DynEntry>,","highlight_start":1,"highlight_end":38},{"text":"    data: &Dav1dFilmGrainData,","highlight_start":1,"highlight_end":31},{"text":"    uv: intptr_t,","highlight_start":1,"highlight_end":18},{"text":"    bitdepth_max: c_int,","highlight_start":1,"highlight_end":25},{"text":") -> ());","highlight_start":1,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"wrap_fn_ptr!","def_site_span":{"file_name":"src/wrap_fn_ptr.rs","byte_start":1818,"byte_end":1842,"line_start":41,"line_end":41,"column_start":1,"column_end":25,"is_primary":false,"text":[{"text":"macro_rules! wrap_fn_ptr {","highlight_start":1,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"#[derive(PartialEq)]","def_site_span":{"file_name":"/rustc/f60a0f1bcc5a2a6dd8eb2d2021da79b40f5fbae9/library/core/src/cmp.rs","byte_start":10192,"byte_end":10211,"line_start":274,"line_end":274,"column_start":1,"column_end":20,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the address of the same function can vary between different codegen units","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"furthermore, different functions could have the same address after being merged together","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more information visit <https://doc.rust-lang.org/nightly/core/ptr/fn.fn_addr_eq.html>","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: function pointer comparisons do not produce meaningful results since their addresses are not guaranteed to be unique\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/wrap_fn_ptr.rs:58:27\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m58\u001b[0m \u001b[1m\u001b[94m|\u001b[0m               pub struct Fn(FnPtr);\n   \u001b[1m\u001b[94m|\u001b[0m                             \u001b[1m\u001b[33m^^^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m::: \u001b[0msrc/filmgrain.rs:71:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m71\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m wrap_fn_ptr!(pub unsafe extern \"C\" fn generate_grain_uv(\n\u001b[1m\u001b[94m72\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     buf: *mut GrainLut<DynEntry>,\n\u001b[1m\u001b[94m73\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     buf_y: *const GrainLut<DynEntry>,\n\u001b[1m\u001b[94m74\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     data: &Dav1dFilmGrainData,\n\u001b[1m\u001b[94m75\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     uv: intptr_t,\n\u001b[1m\u001b[94m76\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     bitdepth_max: c_int,\n\u001b[1m\u001b[94m77\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m ) -> ());\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|________-\u001b[0m \u001b[1m\u001b[94min this macro invocation\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the address of the same function can vary between different codegen units\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: furthermore, different functions could have the same address after being merged together\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for more information visit <https://doc.rust-lang.org/nightly/core/ptr/fn.fn_addr_eq.html>\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this warning originates in the derive macro `PartialEq` which comes from the expansion of the macro `wrap_fn_ptr` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"function pointer comparisons do not produce meaningful results since their addresses are not guaranteed to be unique","code":{"code":"unpredictable_function_pointer_comparisons","explanation":null},"level":"warning","spans":[{"file_name":"src/wrap_fn_ptr.rs","byte_start":2500,"byte_end":2505,"line_start":58,"line_end":58,"column_start":27,"column_end":32,"is_primary":true,"text":[{"text":"            pub struct Fn(FnPtr);","highlight_start":27,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/wrap_fn_ptr.rs","byte_start":2425,"byte_end":2434,"line_start":56,"line_end":56,"column_start":35,"column_end":44,"is_primary":false,"text":[{"text":"            #[derive(Clone, Copy, PartialEq, Eq)]","highlight_start":35,"highlight_end":44}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/filmgrain.rs","byte_start":2937,"byte_end":3391,"line_start":98,"line_end":111,"column_start":1,"column_end":9,"is_primary":false,"text":[{"text":"wrap_fn_ptr!(pub unsafe extern \"C\" fn fgy_32x32xn(","highlight_start":1,"highlight_end":51},{"text":"    dst_row_ptr: *mut DynPixel,","highlight_start":1,"highlight_end":32},{"text":"    src_row_ptr: *const DynPixel,","highlight_start":1,"highlight_end":34},{"text":"    stride: ptrdiff_t,","highlight_start":1,"highlight_end":23},{"text":"    data: &Dav1dFilmGrainData,","highlight_start":1,"highlight_end":31},{"text":"    pw: usize,","highlight_start":1,"highlight_end":15},{"text":"    scaling: *const DynScaling,","highlight_start":1,"highlight_end":32},{"text":"    grain_lut: *const GrainLut<DynEntry>,","highlight_start":1,"highlight_end":42},{"text":"    bh: c_int,","highlight_start":1,"highlight_end":15},{"text":"    row_num: c_int,","highlight_start":1,"highlight_end":20},{"text":"    bitdepth_max: c_int,","highlight_start":1,"highlight_end":25},{"text":"    _dst_row: *const FFISafe<Rav1dPictureDataComponentOffset>,","highlight_start":1,"highlight_end":63},{"text":"    _src_src: *const FFISafe<Rav1dPictureDataComponentOffset>,","highlight_start":1,"highlight_end":63},{"text":") -> ());","highlight_start":1,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"wrap_fn_ptr!","def_site_span":{"file_name":"src/wrap_fn_ptr.rs","byte_start":1818,"byte_end":1842,"line_start":41,"line_end":41,"column_start":1,"column_end":25,"is_primary":false,"text":[{"text":"macro_rules! wrap_fn_ptr {","highlight_start":1,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"#[derive(PartialEq)]","def_site_span":{"file_name":"/rustc/f60a0f1bcc5a2a6dd8eb2d2021da79b40f5fbae9/library/core/src/cmp.rs","byte_start":10192,"byte_end":10211,"line_start":274,"line_end":274,"column_start":1,"column_end":20,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the address of the same function can vary between different codegen units","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"furthermore, different functions could have the same address after being merged together","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more information visit <https://doc.rust-lang.org/nightly/core/ptr/fn.fn_addr_eq.html>","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: function pointer comparisons do not produce meaningful results since their addresses are not guaranteed to be unique\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/wrap_fn_ptr.rs:58:27\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 58\u001b[0m \u001b[1m\u001b[94m|\u001b[0m               pub struct Fn(FnPtr);\n    \u001b[1m\u001b[94m|\u001b[0m                             \u001b[1m\u001b[33m^^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/filmgrain.rs:98:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 98\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m wrap_fn_ptr!(pub unsafe extern \"C\" fn fgy_32x32xn(\n\u001b[1m\u001b[94m 99\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     dst_row_ptr: *mut DynPixel,\n\u001b[1m\u001b[94m100\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     src_row_ptr: *const DynPixel,\n\u001b[1m\u001b[94m101\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     stride: ptrdiff_t,\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m110\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     _src_src: *const FFISafe<Rav1dPictureDataComponentOffset>,\n\u001b[1m\u001b[94m111\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m ) -> ());\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|________-\u001b[0m \u001b[1m\u001b[94min this macro invocation\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the address of the same function can vary between different codegen units\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: furthermore, different functions could have the same address after being merged together\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for more information visit <https://doc.rust-lang.org/nightly/core/ptr/fn.fn_addr_eq.html>\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this warning originates in the derive macro `PartialEq` which comes from the expansion of the macro `wrap_fn_ptr` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"function pointer comparisons do not produce meaningful results since their addresses are not guaranteed to be unique","code":{"code":"unpredictable_function_pointer_comparisons","explanation":null},"level":"warning","spans":[{"file_name":"src/wrap_fn_ptr.rs","byte_start":2500,"byte_end":2505,"line_start":58,"line_end":58,"column_start":27,"column_end":32,"is_primary":true,"text":[{"text":"            pub struct Fn(FnPtr);","highlight_start":27,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/wrap_fn_ptr.rs","byte_start":2425,"byte_end":2434,"line_start":56,"line_end":56,"column_start":35,"column_end":44,"is_primary":false,"text":[{"text":"            #[derive(Clone, Copy, PartialEq, Eq)]","highlight_start":35,"highlight_end":44}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/filmgrain.rs","byte_start":4928,"byte_end":5546,"line_start":160,"line_end":178,"column_start":1,"column_end":9,"is_primary":false,"text":[{"text":"wrap_fn_ptr!(pub unsafe extern \"C\" fn fguv_32x32xn(","highlight_start":1,"highlight_end":52},{"text":"    dst_row_ptr: *mut DynPixel,","highlight_start":1,"highlight_end":32},{"text":"    src_row_ptr: *const DynPixel,","highlight_start":1,"highlight_end":34},{"text":"    stride: ptrdiff_t,","highlight_start":1,"highlight_end":23},{"text":"    data: &Dav1dFilmGrainData,","highlight_start":1,"highlight_end":31},{"text":"    pw: usize,","highlight_start":1,"highlight_end":15},{"text":"    scaling: *const DynScaling,","highlight_start":1,"highlight_end":32},{"text":"    grain_lut: *const GrainLut<DynEntry>,","highlight_start":1,"highlight_end":42},{"text":"    bh: c_int,","highlight_start":1,"highlight_end":15},{"text":"    row_num: c_int,","highlight_start":1,"highlight_end":20},{"text":"    luma_row_ptr: *const DynPixel,","highlight_start":1,"highlight_end":35},{"text":"    luma_stride: ptrdiff_t,","highlight_start":1,"highlight_end":28},{"text":"    uv_pl: c_int,","highlight_start":1,"highlight_end":18},{"text":"    is_id: c_int,","highlight_start":1,"highlight_end":18},{"text":"    bitdepth_max: c_int,","highlight_start":1,"highlight_end":25},{"text":"    _dst_row: *const FFISafe<Rav1dPictureDataComponentOffset>,","highlight_start":1,"highlight_end":63},{"text":"    _src_row: *const FFISafe<Rav1dPictureDataComponentOffset>,","highlight_start":1,"highlight_end":63},{"text":"    _luma_row: *const FFISafe<Rav1dPictureDataComponentOffset>,","highlight_start":1,"highlight_end":64},{"text":") -> ());","highlight_start":1,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"wrap_fn_ptr!","def_site_span":{"file_name":"src/wrap_fn_ptr.rs","byte_start":1818,"byte_end":1842,"line_start":41,"line_end":41,"column_start":1,"column_end":25,"is_primary":false,"text":[{"text":"macro_rules! wrap_fn_ptr {","highlight_start":1,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"#[derive(PartialEq)]","def_site_span":{"file_name":"/rustc/f60a0f1bcc5a2a6dd8eb2d2021da79b40f5fbae9/library/core/src/cmp.rs","byte_start":10192,"byte_end":10211,"line_start":274,"line_end":274,"column_start":1,"column_end":20,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the address of the same function can vary between different codegen units","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"furthermore, different functions could have the same address after being merged together","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more information visit <https://doc.rust-lang.org/nightly/core/ptr/fn.fn_addr_eq.html>","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: function pointer comparisons do not produce meaningful results since their addresses are not guaranteed to be unique\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/wrap_fn_ptr.rs:58:27\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 58\u001b[0m \u001b[1m\u001b[94m|\u001b[0m               pub struct Fn(FnPtr);\n    \u001b[1m\u001b[94m|\u001b[0m                             \u001b[1m\u001b[33m^^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/filmgrain.rs:160:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m160\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m wrap_fn_ptr!(pub unsafe extern \"C\" fn fguv_32x32xn(\n\u001b[1m\u001b[94m161\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     dst_row_ptr: *mut DynPixel,\n\u001b[1m\u001b[94m162\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     src_row_ptr: *const DynPixel,\n\u001b[1m\u001b[94m163\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     stride: ptrdiff_t,\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m177\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     _luma_row: *const FFISafe<Rav1dPictureDataComponentOffset>,\n\u001b[1m\u001b[94m178\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m ) -> ());\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|________-\u001b[0m \u001b[1m\u001b[94min this macro invocation\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the address of the same function can vary between different codegen units\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: furthermore, different functions could have the same address after being merged together\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for more information visit <https://doc.rust-lang.org/nightly/core/ptr/fn.fn_addr_eq.html>\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this warning originates in the derive macro `PartialEq` which comes from the expansion of the macro `wrap_fn_ptr` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"function pointer comparisons do not produce meaningful results since their addresses are not guaranteed to be unique","code":{"code":"unpredictable_function_pointer_comparisons","explanation":null},"level":"warning","spans":[{"file_name":"src/wrap_fn_ptr.rs","byte_start":2500,"byte_end":2505,"line_start":58,"line_end":58,"column_start":27,"column_end":32,"is_primary":true,"text":[{"text":"            pub struct Fn(FnPtr);","highlight_start":27,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/wrap_fn_ptr.rs","byte_start":2425,"byte_end":2434,"line_start":56,"line_end":56,"column_start":35,"column_end":44,"is_primary":false,"text":[{"text":"            #[derive(Clone, Copy, PartialEq, Eq)]","highlight_start":35,"highlight_end":44}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/ipred.rs","byte_start":1971,"byte_end":2322,"line_start":58,"line_end":70,"column_start":1,"column_end":9,"is_primary":false,"text":[{"text":"wrap_fn_ptr!(pub unsafe extern \"C\" fn angular_ipred(","highlight_start":1,"highlight_end":53},{"text":"    dst_ptr: *mut DynPixel,","highlight_start":1,"highlight_end":28},{"text":"    stride: ptrdiff_t,","highlight_start":1,"highlight_end":23},{"text":"    topleft: *const DynPixel,","highlight_start":1,"highlight_end":30},{"text":"    width: c_int,","highlight_start":1,"highlight_end":18},{"text":"    height: c_int,","highlight_start":1,"highlight_end":19},{"text":"    angle: c_int,","highlight_start":1,"highlight_end":18},{"text":"    max_width: c_int,","highlight_start":1,"highlight_end":22},{"text":"    max_height: c_int,","highlight_start":1,"highlight_end":23},{"text":"    bitdepth_max: c_int,","highlight_start":1,"highlight_end":25},{"text":"    _topleft_off: usize,","highlight_start":1,"highlight_end":25},{"text":"    _dst: *const FFISafe<Rav1dPictureDataComponentOffset>,","highlight_start":1,"highlight_end":59},{"text":") -> ());","highlight_start":1,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"wrap_fn_ptr!","def_site_span":{"file_name":"src/wrap_fn_ptr.rs","byte_start":1818,"byte_end":1842,"line_start":41,"line_end":41,"column_start":1,"column_end":25,"is_primary":false,"text":[{"text":"macro_rules! wrap_fn_ptr {","highlight_start":1,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"#[derive(PartialEq)]","def_site_span":{"file_name":"/rustc/f60a0f1bcc5a2a6dd8eb2d2021da79b40f5fbae9/library/core/src/cmp.rs","byte_start":10192,"byte_end":10211,"line_start":274,"line_end":274,"column_start":1,"column_end":20,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the address of the same function can vary between different codegen units","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"furthermore, different functions could have the same address after being merged together","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more information visit <https://doc.rust-lang.org/nightly/core/ptr/fn.fn_addr_eq.html>","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: function pointer comparisons do not produce meaningful results since their addresses are not guaranteed to be unique\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/wrap_fn_ptr.rs:58:27\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m58\u001b[0m \u001b[1m\u001b[94m|\u001b[0m               pub struct Fn(FnPtr);\n   \u001b[1m\u001b[94m|\u001b[0m                             \u001b[1m\u001b[33m^^^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m::: \u001b[0msrc/ipred.rs:58:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m58\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m wrap_fn_ptr!(pub unsafe extern \"C\" fn angular_ipred(\n\u001b[1m\u001b[94m59\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     dst_ptr: *mut DynPixel,\n\u001b[1m\u001b[94m60\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     stride: ptrdiff_t,\n\u001b[1m\u001b[94m61\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     topleft: *const DynPixel,\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m69\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     _dst: *const FFISafe<Rav1dPictureDataComponentOffset>,\n\u001b[1m\u001b[94m70\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m ) -> ());\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|________-\u001b[0m \u001b[1m\u001b[94min this macro invocation\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the address of the same function can vary between different codegen units\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: furthermore, different functions could have the same address after being merged together\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for more information visit <https://doc.rust-lang.org/nightly/core/ptr/fn.fn_addr_eq.html>\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this warning originates in the derive macro `PartialEq` which comes from the expansion of the macro `wrap_fn_ptr` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"function pointer comparisons do not produce meaningful results since their addresses are not guaranteed to be unique","code":{"code":"unpredictable_function_pointer_comparisons","explanation":null},"level":"warning","spans":[{"file_name":"src/wrap_fn_ptr.rs","byte_start":2500,"byte_end":2505,"line_start":58,"line_end":58,"column_start":27,"column_end":32,"is_primary":true,"text":[{"text":"            pub struct Fn(FnPtr);","highlight_start":27,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/wrap_fn_ptr.rs","byte_start":2425,"byte_end":2434,"line_start":56,"line_end":56,"column_start":35,"column_end":44,"is_primary":false,"text":[{"text":"            #[derive(Clone, Copy, PartialEq, Eq)]","highlight_start":35,"highlight_end":44}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/ipred.rs","byte_start":3569,"byte_end":3838,"line_start":116,"line_end":125,"column_start":1,"column_end":9,"is_primary":false,"text":[{"text":"wrap_fn_ptr!(pub unsafe extern \"C\" fn cfl_ac(","highlight_start":1,"highlight_end":46},{"text":"    ac: &mut [i16; SCRATCH_AC_TXTP_LEN],","highlight_start":1,"highlight_end":41},{"text":"    y_ptr: *const DynPixel,","highlight_start":1,"highlight_end":28},{"text":"    stride: ptrdiff_t,","highlight_start":1,"highlight_end":23},{"text":"    w_pad: c_int,","highlight_start":1,"highlight_end":18},{"text":"    h_pad: c_int,","highlight_start":1,"highlight_end":18},{"text":"    cw: c_int,","highlight_start":1,"highlight_end":15},{"text":"    ch: c_int,","highlight_start":1,"highlight_end":15},{"text":"    _y: *const FFISafe<Rav1dPictureDataComponentOffset>,","highlight_start":1,"highlight_end":57},{"text":") -> ());","highlight_start":1,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"wrap_fn_ptr!","def_site_span":{"file_name":"src/wrap_fn_ptr.rs","byte_start":1818,"byte_end":1842,"line_start":41,"line_end":41,"column_start":1,"column_end":25,"is_primary":false,"text":[{"text":"macro_rules! wrap_fn_ptr {","highlight_start":1,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"#[derive(PartialEq)]","def_site_span":{"file_name":"/rustc/f60a0f1bcc5a2a6dd8eb2d2021da79b40f5fbae9/library/core/src/cmp.rs","byte_start":10192,"byte_end":10211,"line_start":274,"line_end":274,"column_start":1,"column_end":20,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the address of the same function can vary between different codegen units","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"furthermore, different functions could have the same address after being merged together","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more information visit <https://doc.rust-lang.org/nightly/core/ptr/fn.fn_addr_eq.html>","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: function pointer comparisons do not produce meaningful results since their addresses are not guaranteed to be unique\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/wrap_fn_ptr.rs:58:27\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 58\u001b[0m \u001b[1m\u001b[94m|\u001b[0m               pub struct Fn(FnPtr);\n    \u001b[1m\u001b[94m|\u001b[0m                             \u001b[1m\u001b[33m^^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/ipred.rs:116:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m116\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m wrap_fn_ptr!(pub unsafe extern \"C\" fn cfl_ac(\n\u001b[1m\u001b[94m117\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     ac: &mut [i16; SCRATCH_AC_TXTP_LEN],\n\u001b[1m\u001b[94m118\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     y_ptr: *const DynPixel,\n\u001b[1m\u001b[94m119\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     stride: ptrdiff_t,\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m124\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     _y: *const FFISafe<Rav1dPictureDataComponentOffset>,\n\u001b[1m\u001b[94m125\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m ) -> ());\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|________-\u001b[0m \u001b[1m\u001b[94min this macro invocation\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the address of the same function can vary between different codegen units\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: furthermore, different functions could have the same address after being merged together\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for more information visit <https://doc.rust-lang.org/nightly/core/ptr/fn.fn_addr_eq.html>\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this warning originates in the derive macro `PartialEq` which comes from the expansion of the macro `wrap_fn_ptr` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"function pointer comparisons do not produce meaningful results since their addresses are not guaranteed to be unique","code":{"code":"unpredictable_function_pointer_comparisons","explanation":null},"level":"warning","spans":[{"file_name":"src/wrap_fn_ptr.rs","byte_start":2500,"byte_end":2505,"line_start":58,"line_end":58,"column_start":27,"column_end":32,"is_primary":true,"text":[{"text":"            pub struct Fn(FnPtr);","highlight_start":27,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/wrap_fn_ptr.rs","byte_start":2425,"byte_end":2434,"line_start":56,"line_end":56,"column_start":35,"column_end":44,"is_primary":false,"text":[{"text":"            #[derive(Clone, Copy, PartialEq, Eq)]","highlight_start":35,"highlight_end":44}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/ipred.rs","byte_start":4365,"byte_end":4703,"line_start":145,"line_end":156,"column_start":1,"column_end":9,"is_primary":false,"text":[{"text":"wrap_fn_ptr!(pub unsafe extern \"C\" fn cfl_pred(","highlight_start":1,"highlight_end":48},{"text":"    dst_ptr: *mut DynPixel,","highlight_start":1,"highlight_end":28},{"text":"    stride: ptrdiff_t,","highlight_start":1,"highlight_end":23},{"text":"    topleft: *const DynPixel,","highlight_start":1,"highlight_end":30},{"text":"    width: c_int,","highlight_start":1,"highlight_end":18},{"text":"    height: c_int,","highlight_start":1,"highlight_end":19},{"text":"    ac: &[i16; SCRATCH_AC_TXTP_LEN],","highlight_start":1,"highlight_end":37},{"text":"    alpha: c_int,","highlight_start":1,"highlight_end":18},{"text":"    bitdepth_max: c_int,","highlight_start":1,"highlight_end":25},{"text":"    _topleft_off: usize,","highlight_start":1,"highlight_end":25},{"text":"    _dst: *const FFISafe<Rav1dPictureDataComponentOffset>,","highlight_start":1,"highlight_end":59},{"text":") -> ());","highlight_start":1,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"wrap_fn_ptr!","def_site_span":{"file_name":"src/wrap_fn_ptr.rs","byte_start":1818,"byte_end":1842,"line_start":41,"line_end":41,"column_start":1,"column_end":25,"is_primary":false,"text":[{"text":"macro_rules! wrap_fn_ptr {","highlight_start":1,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"#[derive(PartialEq)]","def_site_span":{"file_name":"/rustc/f60a0f1bcc5a2a6dd8eb2d2021da79b40f5fbae9/library/core/src/cmp.rs","byte_start":10192,"byte_end":10211,"line_start":274,"line_end":274,"column_start":1,"column_end":20,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the address of the same function can vary between different codegen units","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"furthermore, different functions could have the same address after being merged together","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more information visit <https://doc.rust-lang.org/nightly/core/ptr/fn.fn_addr_eq.html>","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: function pointer comparisons do not produce meaningful results since their addresses are not guaranteed to be unique\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/wrap_fn_ptr.rs:58:27\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 58\u001b[0m \u001b[1m\u001b[94m|\u001b[0m               pub struct Fn(FnPtr);\n    \u001b[1m\u001b[94m|\u001b[0m                             \u001b[1m\u001b[33m^^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/ipred.rs:145:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m145\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m wrap_fn_ptr!(pub unsafe extern \"C\" fn cfl_pred(\n\u001b[1m\u001b[94m146\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     dst_ptr: *mut DynPixel,\n\u001b[1m\u001b[94m147\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     stride: ptrdiff_t,\n\u001b[1m\u001b[94m148\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     topleft: *const DynPixel,\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m155\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     _dst: *const FFISafe<Rav1dPictureDataComponentOffset>,\n\u001b[1m\u001b[94m156\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m ) -> ());\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|________-\u001b[0m \u001b[1m\u001b[94min this macro invocation\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the address of the same function can vary between different codegen units\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: furthermore, different functions could have the same address after being merged together\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for more information visit <https://doc.rust-lang.org/nightly/core/ptr/fn.fn_addr_eq.html>\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this warning originates in the derive macro `PartialEq` which comes from the expansion of the macro `wrap_fn_ptr` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"function pointer comparisons do not produce meaningful results since their addresses are not guaranteed to be unique","code":{"code":"unpredictable_function_pointer_comparisons","explanation":null},"level":"warning","spans":[{"file_name":"src/wrap_fn_ptr.rs","byte_start":2500,"byte_end":2505,"line_start":58,"line_end":58,"column_start":27,"column_end":32,"is_primary":true,"text":[{"text":"            pub struct Fn(FnPtr);","highlight_start":27,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/wrap_fn_ptr.rs","byte_start":2425,"byte_end":2434,"line_start":56,"line_end":56,"column_start":35,"column_end":44,"is_primary":false,"text":[{"text":"            #[derive(Clone, Copy, PartialEq, Eq)]","highlight_start":35,"highlight_end":44}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/ipred.rs","byte_start":5636,"byte_end":5881,"line_start":193,"line_end":201,"column_start":1,"column_end":9,"is_primary":false,"text":[{"text":"wrap_fn_ptr!(pub unsafe extern \"C\" fn pal_pred(","highlight_start":1,"highlight_end":48},{"text":"    dst_ptr: *mut DynPixel,","highlight_start":1,"highlight_end":28},{"text":"    stride: ptrdiff_t,","highlight_start":1,"highlight_end":23},{"text":"    pal: *const [DynPixel; 8],","highlight_start":1,"highlight_end":31},{"text":"    idx: *const u8,","highlight_start":1,"highlight_end":20},{"text":"    w: c_int,","highlight_start":1,"highlight_end":14},{"text":"    h: c_int,","highlight_start":1,"highlight_end":14},{"text":"    _dst: *const FFISafe<Rav1dPictureDataComponentOffset>,","highlight_start":1,"highlight_end":59},{"text":") -> ());","highlight_start":1,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"wrap_fn_ptr!","def_site_span":{"file_name":"src/wrap_fn_ptr.rs","byte_start":1818,"byte_end":1842,"line_start":41,"line_end":41,"column_start":1,"column_end":25,"is_primary":false,"text":[{"text":"macro_rules! wrap_fn_ptr {","highlight_start":1,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"#[derive(PartialEq)]","def_site_span":{"file_name":"/rustc/f60a0f1bcc5a2a6dd8eb2d2021da79b40f5fbae9/library/core/src/cmp.rs","byte_start":10192,"byte_end":10211,"line_start":274,"line_end":274,"column_start":1,"column_end":20,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the address of the same function can vary between different codegen units","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"furthermore, different functions could have the same address after being merged together","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more information visit <https://doc.rust-lang.org/nightly/core/ptr/fn.fn_addr_eq.html>","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: function pointer comparisons do not produce meaningful results since their addresses are not guaranteed to be unique\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/wrap_fn_ptr.rs:58:27\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 58\u001b[0m \u001b[1m\u001b[94m|\u001b[0m               pub struct Fn(FnPtr);\n    \u001b[1m\u001b[94m|\u001b[0m                             \u001b[1m\u001b[33m^^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/ipred.rs:193:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m193\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m wrap_fn_ptr!(pub unsafe extern \"C\" fn pal_pred(\n\u001b[1m\u001b[94m194\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     dst_ptr: *mut DynPixel,\n\u001b[1m\u001b[94m195\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     stride: ptrdiff_t,\n\u001b[1m\u001b[94m196\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pal: *const [DynPixel; 8],\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m200\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     _dst: *const FFISafe<Rav1dPictureDataComponentOffset>,\n\u001b[1m\u001b[94m201\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m ) -> ());\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|________-\u001b[0m \u001b[1m\u001b[94min this macro invocation\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the address of the same function can vary between different codegen units\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: furthermore, different functions could have the same address after being merged together\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for more information visit <https://doc.rust-lang.org/nightly/core/ptr/fn.fn_addr_eq.html>\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this warning originates in the derive macro `PartialEq` which comes from the expansion of the macro `wrap_fn_ptr` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"function pointer comparisons do not produce meaningful results since their addresses are not guaranteed to be unique","code":{"code":"unpredictable_function_pointer_comparisons","explanation":null},"level":"warning","spans":[{"file_name":"src/wrap_fn_ptr.rs","byte_start":2500,"byte_end":2505,"line_start":58,"line_end":58,"column_start":27,"column_end":32,"is_primary":true,"text":[{"text":"            pub struct Fn(FnPtr);","highlight_start":27,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/wrap_fn_ptr.rs","byte_start":2425,"byte_end":2434,"line_start":56,"line_end":56,"column_start":35,"column_end":44,"is_primary":false,"text":[{"text":"            #[derive(Clone, Copy, PartialEq, Eq)]","highlight_start":35,"highlight_end":44}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/itx.rs","byte_start":8529,"byte_end":8771,"line_start":285,"line_end":293,"column_start":1,"column_end":9,"is_primary":false,"text":[{"text":"wrap_fn_ptr!(unsafe extern \"C\" fn itxfm(","highlight_start":1,"highlight_end":41},{"text":"    dst_ptr: *mut DynPixel,","highlight_start":1,"highlight_end":28},{"text":"    dst_stride: isize,","highlight_start":1,"highlight_end":23},{"text":"    coeff: *mut DynCoef,","highlight_start":1,"highlight_end":25},{"text":"    eob: i32,","highlight_start":1,"highlight_end":14},{"text":"    bitdepth_max: i32,","highlight_start":1,"highlight_end":23},{"text":"    _coeff_len: u16,","highlight_start":1,"highlight_end":21},{"text":"    _dst: *const FFISafe<Rav1dPictureDataComponentOffset>,","highlight_start":1,"highlight_end":59},{"text":") -> ());","highlight_start":1,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"wrap_fn_ptr!","def_site_span":{"file_name":"src/wrap_fn_ptr.rs","byte_start":1818,"byte_end":1842,"line_start":41,"line_end":41,"column_start":1,"column_end":25,"is_primary":false,"text":[{"text":"macro_rules! wrap_fn_ptr {","highlight_start":1,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"#[derive(PartialEq)]","def_site_span":{"file_name":"/rustc/f60a0f1bcc5a2a6dd8eb2d2021da79b40f5fbae9/library/core/src/cmp.rs","byte_start":10192,"byte_end":10211,"line_start":274,"line_end":274,"column_start":1,"column_end":20,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the address of the same function can vary between different codegen units","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"furthermore, different functions could have the same address after being merged together","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more information visit <https://doc.rust-lang.org/nightly/core/ptr/fn.fn_addr_eq.html>","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: function pointer comparisons do not produce meaningful results since their addresses are not guaranteed to be unique\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/wrap_fn_ptr.rs:58:27\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 58\u001b[0m \u001b[1m\u001b[94m|\u001b[0m               pub struct Fn(FnPtr);\n    \u001b[1m\u001b[94m|\u001b[0m                             \u001b[1m\u001b[33m^^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/itx.rs:285:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m285\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m wrap_fn_ptr!(unsafe extern \"C\" fn itxfm(\n\u001b[1m\u001b[94m286\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     dst_ptr: *mut DynPixel,\n\u001b[1m\u001b[94m287\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     dst_stride: isize,\n\u001b[1m\u001b[94m288\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     coeff: *mut DynCoef,\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m292\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     _dst: *const FFISafe<Rav1dPictureDataComponentOffset>,\n\u001b[1m\u001b[94m293\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m ) -> ());\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|________-\u001b[0m \u001b[1m\u001b[94min this macro invocation\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the address of the same function can vary between different codegen units\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: furthermore, different functions could have the same address after being merged together\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for more information visit <https://doc.rust-lang.org/nightly/core/ptr/fn.fn_addr_eq.html>\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this warning originates in the derive macro `PartialEq` which comes from the expansion of the macro `wrap_fn_ptr` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"function pointer comparisons do not produce meaningful results since their addresses are not guaranteed to be unique","code":{"code":"unpredictable_function_pointer_comparisons","explanation":null},"level":"warning","spans":[{"file_name":"src/wrap_fn_ptr.rs","byte_start":2500,"byte_end":2505,"line_start":58,"line_end":58,"column_start":27,"column_end":32,"is_primary":true,"text":[{"text":"            pub struct Fn(FnPtr);","highlight_start":27,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/wrap_fn_ptr.rs","byte_start":2425,"byte_end":2434,"line_start":56,"line_end":56,"column_start":35,"column_end":44,"is_primary":false,"text":[{"text":"            #[derive(Clone, Copy, PartialEq, Eq)]","highlight_start":35,"highlight_end":44}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/loopfilter.rs","byte_start":860,"byte_end":1240,"line_start":28,"line_end":39,"column_start":1,"column_end":9,"is_primary":false,"text":[{"text":"wrap_fn_ptr!(pub unsafe extern \"C\" fn loopfilter_sb(","highlight_start":1,"highlight_end":53},{"text":"    dst_ptr: *mut DynPixel,","highlight_start":1,"highlight_end":28},{"text":"    stride: ptrdiff_t,","highlight_start":1,"highlight_end":23},{"text":"    mask: &[u32; 3],","highlight_start":1,"highlight_end":21},{"text":"    lvl_ptr: *const [u8; 4],","highlight_start":1,"highlight_end":29},{"text":"    b4_stride: ptrdiff_t,","highlight_start":1,"highlight_end":26},{"text":"    lut: &Align16<Av1FilterLUT>,","highlight_start":1,"highlight_end":33},{"text":"    w: c_int,","highlight_start":1,"highlight_end":14},{"text":"    bitdepth_max: c_int,","highlight_start":1,"highlight_end":25},{"text":"    _dst: *const FFISafe<Rav1dPictureDataComponentOffset>,","highlight_start":1,"highlight_end":59},{"text":"    _lvl: *const FFISafe<WithOffset<&DisjointMut<Vec<u8>>>>,","highlight_start":1,"highlight_end":61},{"text":") -> ());","highlight_start":1,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"wrap_fn_ptr!","def_site_span":{"file_name":"src/wrap_fn_ptr.rs","byte_start":1818,"byte_end":1842,"line_start":41,"line_end":41,"column_start":1,"column_end":25,"is_primary":false,"text":[{"text":"macro_rules! wrap_fn_ptr {","highlight_start":1,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"#[derive(PartialEq)]","def_site_span":{"file_name":"/rustc/f60a0f1bcc5a2a6dd8eb2d2021da79b40f5fbae9/library/core/src/cmp.rs","byte_start":10192,"byte_end":10211,"line_start":274,"line_end":274,"column_start":1,"column_end":20,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the address of the same function can vary between different codegen units","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"furthermore, different functions could have the same address after being merged together","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more information visit <https://doc.rust-lang.org/nightly/core/ptr/fn.fn_addr_eq.html>","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: function pointer comparisons do not produce meaningful results since their addresses are not guaranteed to be unique\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/wrap_fn_ptr.rs:58:27\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m58\u001b[0m \u001b[1m\u001b[94m|\u001b[0m               pub struct Fn(FnPtr);\n   \u001b[1m\u001b[94m|\u001b[0m                             \u001b[1m\u001b[33m^^^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m::: \u001b[0msrc/loopfilter.rs:28:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m28\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m wrap_fn_ptr!(pub unsafe extern \"C\" fn loopfilter_sb(\n\u001b[1m\u001b[94m29\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     dst_ptr: *mut DynPixel,\n\u001b[1m\u001b[94m30\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     stride: ptrdiff_t,\n\u001b[1m\u001b[94m31\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     mask: &[u32; 3],\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     _lvl: *const FFISafe<WithOffset<&DisjointMut<Vec<u8>>>>,\n\u001b[1m\u001b[94m39\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m ) -> ());\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|________-\u001b[0m \u001b[1m\u001b[94min this macro invocation\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the address of the same function can vary between different codegen units\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: furthermore, different functions could have the same address after being merged together\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for more information visit <https://doc.rust-lang.org/nightly/core/ptr/fn.fn_addr_eq.html>\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this warning originates in the derive macro `PartialEq` which comes from the expansion of the macro `wrap_fn_ptr` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"function pointer comparisons do not produce meaningful results since their addresses are not guaranteed to be unique","code":{"code":"unpredictable_function_pointer_comparisons","explanation":null},"level":"warning","spans":[{"file_name":"src/wrap_fn_ptr.rs","byte_start":2500,"byte_end":2505,"line_start":58,"line_end":58,"column_start":27,"column_end":32,"is_primary":true,"text":[{"text":"            pub struct Fn(FnPtr);","highlight_start":27,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/wrap_fn_ptr.rs","byte_start":2425,"byte_end":2434,"line_start":56,"line_end":56,"column_start":35,"column_end":44,"is_primary":false,"text":[{"text":"            #[derive(Clone, Copy, PartialEq, Eq)]","highlight_start":35,"highlight_end":44}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/looprestoration.rs","byte_start":3323,"byte_end":3749,"line_start":111,"line_end":123,"column_start":1,"column_end":9,"is_primary":false,"text":[{"text":"wrap_fn_ptr!(pub unsafe extern \"C\" fn loop_restoration_filter(","highlight_start":1,"highlight_end":63},{"text":"    dst_ptr: *mut DynPixel,","highlight_start":1,"highlight_end":28},{"text":"    dst_stride: ptrdiff_t,","highlight_start":1,"highlight_end":27},{"text":"    left: *const LeftPixelRow<DynPixel>,","highlight_start":1,"highlight_end":41},{"text":"    lpf_ptr: *const DynPixel,","highlight_start":1,"highlight_end":30},{"text":"    w: c_int,","highlight_start":1,"highlight_end":14},{"text":"    h: c_int,","highlight_start":1,"highlight_end":14},{"text":"    params: &LooprestorationParams,","highlight_start":1,"highlight_end":36},{"text":"    edges: LrEdgeFlags,","highlight_start":1,"highlight_end":24},{"text":"    bitdepth_max: c_int,","highlight_start":1,"highlight_end":25},{"text":"    _dst: *const FFISafe<Rav1dPictureDataComponentOffset>,","highlight_start":1,"highlight_end":59},{"text":"    _lpf: *const FFISafe<DisjointMut<AlignedVec64<u8>>>,","highlight_start":1,"highlight_end":57},{"text":") -> ());","highlight_start":1,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"wrap_fn_ptr!","def_site_span":{"file_name":"src/wrap_fn_ptr.rs","byte_start":1818,"byte_end":1842,"line_start":41,"line_end":41,"column_start":1,"column_end":25,"is_primary":false,"text":[{"text":"macro_rules! wrap_fn_ptr {","highlight_start":1,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"#[derive(PartialEq)]","def_site_span":{"file_name":"/rustc/f60a0f1bcc5a2a6dd8eb2d2021da79b40f5fbae9/library/core/src/cmp.rs","byte_start":10192,"byte_end":10211,"line_start":274,"line_end":274,"column_start":1,"column_end":20,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the address of the same function can vary between different codegen units","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"furthermore, different functions could have the same address after being merged together","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more information visit <https://doc.rust-lang.org/nightly/core/ptr/fn.fn_addr_eq.html>","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: function pointer comparisons do not produce meaningful results since their addresses are not guaranteed to be unique\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/wrap_fn_ptr.rs:58:27\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 58\u001b[0m \u001b[1m\u001b[94m|\u001b[0m               pub struct Fn(FnPtr);\n    \u001b[1m\u001b[94m|\u001b[0m                             \u001b[1m\u001b[33m^^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/looprestoration.rs:111:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m111\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m wrap_fn_ptr!(pub unsafe extern \"C\" fn loop_restoration_filter(\n\u001b[1m\u001b[94m112\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     dst_ptr: *mut DynPixel,\n\u001b[1m\u001b[94m113\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     dst_stride: ptrdiff_t,\n\u001b[1m\u001b[94m114\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     left: *const LeftPixelRow<DynPixel>,\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m122\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     _lpf: *const FFISafe<DisjointMut<AlignedVec64<u8>>>,\n\u001b[1m\u001b[94m123\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m ) -> ());\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|________-\u001b[0m \u001b[1m\u001b[94min this macro invocation\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the address of the same function can vary between different codegen units\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: furthermore, different functions could have the same address after being merged together\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for more information visit <https://doc.rust-lang.org/nightly/core/ptr/fn.fn_addr_eq.html>\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this warning originates in the derive macro `PartialEq` which comes from the expansion of the macro `wrap_fn_ptr` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"function pointer comparisons do not produce meaningful results since their addresses are not guaranteed to be unique","code":{"code":"unpredictable_function_pointer_comparisons","explanation":null},"level":"warning","spans":[{"file_name":"src/wrap_fn_ptr.rs","byte_start":2500,"byte_end":2505,"line_start":58,"line_end":58,"column_start":27,"column_end":32,"is_primary":true,"text":[{"text":"            pub struct Fn(FnPtr);","highlight_start":27,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/wrap_fn_ptr.rs","byte_start":2425,"byte_end":2434,"line_start":56,"line_end":56,"column_start":35,"column_end":44,"is_primary":false,"text":[{"text":"            #[derive(Clone, Copy, PartialEq, Eq)]","highlight_start":35,"highlight_end":44}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/mc.rs","byte_start":31924,"byte_end":32269,"line_start":1038,"line_end":1050,"column_start":1,"column_end":9,"is_primary":false,"text":[{"text":"wrap_fn_ptr!(pub unsafe extern \"C\" fn mc(","highlight_start":1,"highlight_end":42},{"text":"    dst_ptr: *mut DynPixel,","highlight_start":1,"highlight_end":28},{"text":"    dst_stride: isize,","highlight_start":1,"highlight_end":23},{"text":"    src_ptr: *const DynPixel,","highlight_start":1,"highlight_end":30},{"text":"    src_stride: isize,","highlight_start":1,"highlight_end":23},{"text":"    w: i32,","highlight_start":1,"highlight_end":12},{"text":"    h: i32,","highlight_start":1,"highlight_end":12},{"text":"    mx: i32,","highlight_start":1,"highlight_end":13},{"text":"    my: i32,","highlight_start":1,"highlight_end":13},{"text":"    bitdepth_max: i32,","highlight_start":1,"highlight_end":23},{"text":"    _dst: *const FFISafe<Rav1dPictureDataComponentOffset>,","highlight_start":1,"highlight_end":59},{"text":"    _src: *const FFISafe<Rav1dPictureDataComponentOffset>,","highlight_start":1,"highlight_end":59},{"text":") -> ());","highlight_start":1,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"wrap_fn_ptr!","def_site_span":{"file_name":"src/wrap_fn_ptr.rs","byte_start":1818,"byte_end":1842,"line_start":41,"line_end":41,"column_start":1,"column_end":25,"is_primary":false,"text":[{"text":"macro_rules! wrap_fn_ptr {","highlight_start":1,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"#[derive(PartialEq)]","def_site_span":{"file_name":"/rustc/f60a0f1bcc5a2a6dd8eb2d2021da79b40f5fbae9/library/core/src/cmp.rs","byte_start":10192,"byte_end":10211,"line_start":274,"line_end":274,"column_start":1,"column_end":20,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the address of the same function can vary between different codegen units","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"furthermore, different functions could have the same address after being merged together","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more information visit <https://doc.rust-lang.org/nightly/core/ptr/fn.fn_addr_eq.html>","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: function pointer comparisons do not produce meaningful results since their addresses are not guaranteed to be unique\u001b[0m\n    \u001b[1m\u001b[94m--> \u001b[0msrc/wrap_fn_ptr.rs:58:27\n     \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m  58\u001b[0m \u001b[1m\u001b[94m|\u001b[0m               pub struct Fn(FnPtr);\n     \u001b[1m\u001b[94m|\u001b[0m                             \u001b[1m\u001b[33m^^^^^\u001b[0m\n     \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m::: \u001b[0msrc/mc.rs:1038:1\n     \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m1038\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m wrap_fn_ptr!(pub unsafe extern \"C\" fn mc(\n\u001b[1m\u001b[94m1039\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     dst_ptr: *mut DynPixel,\n\u001b[1m\u001b[94m1040\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     dst_stride: isize,\n\u001b[1m\u001b[94m1041\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     src_ptr: *const DynPixel,\n\u001b[1m\u001b[94m...\u001b[0m    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m1049\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     _src: *const FFISafe<Rav1dPictureDataComponentOffset>,\n\u001b[1m\u001b[94m1050\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m ) -> ());\n     \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|________-\u001b[0m \u001b[1m\u001b[94min this macro invocation\u001b[0m\n     \u001b[1m\u001b[94m|\u001b[0m\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the address of the same function can vary between different codegen units\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: furthermore, different functions could have the same address after being merged together\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for more information visit <https://doc.rust-lang.org/nightly/core/ptr/fn.fn_addr_eq.html>\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this warning originates in the derive macro `PartialEq` which comes from the expansion of the macro `wrap_fn_ptr` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"function pointer comparisons do not produce meaningful results since their addresses are not guaranteed to be unique","code":{"code":"unpredictable_function_pointer_comparisons","explanation":null},"level":"warning","spans":[{"file_name":"src/wrap_fn_ptr.rs","byte_start":2500,"byte_end":2505,"line_start":58,"line_end":58,"column_start":27,"column_end":32,"is_primary":true,"text":[{"text":"            pub struct Fn(FnPtr);","highlight_start":27,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/wrap_fn_ptr.rs","byte_start":2425,"byte_end":2434,"line_start":56,"line_end":56,"column_start":35,"column_end":44,"is_primary":false,"text":[{"text":"            #[derive(Clone, Copy, PartialEq, Eq)]","highlight_start":35,"highlight_end":44}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/mc.rs","byte_start":33059,"byte_end":33437,"line_start":1079,"line_end":1093,"column_start":1,"column_end":9,"is_primary":false,"text":[{"text":"wrap_fn_ptr!(pub unsafe extern \"C\" fn mc_scaled(","highlight_start":1,"highlight_end":49},{"text":"    dst_ptr: *mut DynPixel,","highlight_start":1,"highlight_end":28},{"text":"    dst_stride: isize,","highlight_start":1,"highlight_end":23},{"text":"    src_ptr: *const DynPixel,","highlight_start":1,"highlight_end":30},{"text":"    src_stride: isize,","highlight_start":1,"highlight_end":23},{"text":"    w: i32,","highlight_start":1,"highlight_end":12},{"text":"    h: i32,","highlight_start":1,"highlight_end":12},{"text":"    mx: i32,","highlight_start":1,"highlight_end":13},{"text":"    my: i32,","highlight_start":1,"highlight_end":13},{"text":"    dx: i32,","highlight_start":1,"highlight_end":13},{"text":"    dy: i32,","highlight_start":1,"highlight_end":13},{"text":"    bitdepth_max: i32,","highlight_start":1,"highlight_end":23},{"text":"    _dst: *const FFISafe<Rav1dPictureDataComponentOffset>,","highlight_start":1,"highlight_end":59},{"text":"    _src: *const FFISafe<Rav1dPictureDataComponentOffset>,","highlight_start":1,"highlight_end":59},{"text":") -> ());","highlight_start":1,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"wrap_fn_ptr!","def_site_span":{"file_name":"src/wrap_fn_ptr.rs","byte_start":1818,"byte_end":1842,"line_start":41,"line_end":41,"column_start":1,"column_end":25,"is_primary":false,"text":[{"text":"macro_rules! wrap_fn_ptr {","highlight_start":1,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"#[derive(PartialEq)]","def_site_span":{"file_name":"/rustc/f60a0f1bcc5a2a6dd8eb2d2021da79b40f5fbae9/library/core/src/cmp.rs","byte_start":10192,"byte_end":10211,"line_start":274,"line_end":274,"column_start":1,"column_end":20,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the address of the same function can vary between different codegen units","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"furthermore, different functions could have the same address after being merged together","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more information visit <https://doc.rust-lang.org/nightly/core/ptr/fn.fn_addr_eq.html>","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: function pointer comparisons do not produce meaningful results since their addresses are not guaranteed to be unique\u001b[0m\n    \u001b[1m\u001b[94m--> \u001b[0msrc/wrap_fn_ptr.rs:58:27\n     \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m  58\u001b[0m \u001b[1m\u001b[94m|\u001b[0m               pub struct Fn(FnPtr);\n     \u001b[1m\u001b[94m|\u001b[0m                             \u001b[1m\u001b[33m^^^^^\u001b[0m\n     \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m::: \u001b[0msrc/mc.rs:1079:1\n     \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m1079\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m wrap_fn_ptr!(pub unsafe extern \"C\" fn mc_scaled(\n\u001b[1m\u001b[94m1080\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     dst_ptr: *mut DynPixel,\n\u001b[1m\u001b[94m1081\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     dst_stride: isize,\n\u001b[1m\u001b[94m1082\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     src_ptr: *const DynPixel,\n\u001b[1m\u001b[94m...\u001b[0m    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m1092\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     _src: *const FFISafe<Rav1dPictureDataComponentOffset>,\n\u001b[1m\u001b[94m1093\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m ) -> ());\n     \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|________-\u001b[0m \u001b[1m\u001b[94min this macro invocation\u001b[0m\n     \u001b[1m\u001b[94m|\u001b[0m\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the address of the same function can vary between different codegen units\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: furthermore, different functions could have the same address after being merged together\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for more information visit <https://doc.rust-lang.org/nightly/core/ptr/fn.fn_addr_eq.html>\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this warning originates in the derive macro `PartialEq` which comes from the expansion of the macro `wrap_fn_ptr` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"function pointer comparisons do not produce meaningful results since their addresses are not guaranteed to be unique","code":{"code":"unpredictable_function_pointer_comparisons","explanation":null},"level":"warning","spans":[{"file_name":"src/wrap_fn_ptr.rs","byte_start":2500,"byte_end":2505,"line_start":58,"line_end":58,"column_start":27,"column_end":32,"is_primary":true,"text":[{"text":"            pub struct Fn(FnPtr);","highlight_start":27,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/wrap_fn_ptr.rs","byte_start":2425,"byte_end":2434,"line_start":56,"line_end":56,"column_start":35,"column_end":44,"is_primary":false,"text":[{"text":"            #[derive(Clone, Copy, PartialEq, Eq)]","highlight_start":35,"highlight_end":44}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/mc.rs","byte_start":34283,"byte_end":34630,"line_start":1124,"line_end":1135,"column_start":1,"column_end":9,"is_primary":false,"text":[{"text":"wrap_fn_ptr!(pub unsafe extern \"C\" fn warp8x8(","highlight_start":1,"highlight_end":47},{"text":"    dst_ptr: *mut DynPixel,","highlight_start":1,"highlight_end":28},{"text":"    dst_stride: isize,","highlight_start":1,"highlight_end":23},{"text":"    src_ptr: *const DynPixel,","highlight_start":1,"highlight_end":30},{"text":"    src_stride: isize,","highlight_start":1,"highlight_end":23},{"text":"    abcd: &[i16; 4],","highlight_start":1,"highlight_end":21},{"text":"    mx: i32,","highlight_start":1,"highlight_end":13},{"text":"    my: i32,","highlight_start":1,"highlight_end":13},{"text":"    bitdepth_max: i32,","highlight_start":1,"highlight_end":23},{"text":"    _dst: *const FFISafe<Rav1dPictureDataComponentOffset>,","highlight_start":1,"highlight_end":59},{"text":"    _src: *const FFISafe<Rav1dPictureDataComponentOffset>,","highlight_start":1,"highlight_end":59},{"text":") -> ());","highlight_start":1,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"wrap_fn_ptr!","def_site_span":{"file_name":"src/wrap_fn_ptr.rs","byte_start":1818,"byte_end":1842,"line_start":41,"line_end":41,"column_start":1,"column_end":25,"is_primary":false,"text":[{"text":"macro_rules! wrap_fn_ptr {","highlight_start":1,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"#[derive(PartialEq)]","def_site_span":{"file_name":"/rustc/f60a0f1bcc5a2a6dd8eb2d2021da79b40f5fbae9/library/core/src/cmp.rs","byte_start":10192,"byte_end":10211,"line_start":274,"line_end":274,"column_start":1,"column_end":20,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the address of the same function can vary between different codegen units","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"furthermore, different functions could have the same address after being merged together","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more information visit <https://doc.rust-lang.org/nightly/core/ptr/fn.fn_addr_eq.html>","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: function pointer comparisons do not produce meaningful results since their addresses are not guaranteed to be unique\u001b[0m\n    \u001b[1m\u001b[94m--> \u001b[0msrc/wrap_fn_ptr.rs:58:27\n     \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m  58\u001b[0m \u001b[1m\u001b[94m|\u001b[0m               pub struct Fn(FnPtr);\n     \u001b[1m\u001b[94m|\u001b[0m                             \u001b[1m\u001b[33m^^^^^\u001b[0m\n     \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m::: \u001b[0msrc/mc.rs:1124:1\n     \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m1124\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m wrap_fn_ptr!(pub unsafe extern \"C\" fn warp8x8(\n\u001b[1m\u001b[94m1125\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     dst_ptr: *mut DynPixel,\n\u001b[1m\u001b[94m1126\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     dst_stride: isize,\n\u001b[1m\u001b[94m1127\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     src_ptr: *const DynPixel,\n\u001b[1m\u001b[94m...\u001b[0m    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m1134\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     _src: *const FFISafe<Rav1dPictureDataComponentOffset>,\n\u001b[1m\u001b[94m1135\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m ) -> ());\n     \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|________-\u001b[0m \u001b[1m\u001b[94min this macro invocation\u001b[0m\n     \u001b[1m\u001b[94m|\u001b[0m\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the address of the same function can vary between different codegen units\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: furthermore, different functions could have the same address after being merged together\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for more information visit <https://doc.rust-lang.org/nightly/core/ptr/fn.fn_addr_eq.html>\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this warning originates in the derive macro `PartialEq` which comes from the expansion of the macro `wrap_fn_ptr` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"function pointer comparisons do not produce meaningful results since their addresses are not guaranteed to be unique","code":{"code":"unpredictable_function_pointer_comparisons","explanation":null},"level":"warning","spans":[{"file_name":"src/wrap_fn_ptr.rs","byte_start":2500,"byte_end":2505,"line_start":58,"line_end":58,"column_start":27,"column_end":32,"is_primary":true,"text":[{"text":"            pub struct Fn(FnPtr);","highlight_start":27,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/wrap_fn_ptr.rs","byte_start":2425,"byte_end":2434,"line_start":56,"line_end":56,"column_start":35,"column_end":44,"is_primary":false,"text":[{"text":"            #[derive(Clone, Copy, PartialEq, Eq)]","highlight_start":35,"highlight_end":44}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/mc.rs","byte_start":35405,"byte_end":35660,"line_start":1163,"line_end":1173,"column_start":1,"column_end":9,"is_primary":false,"text":[{"text":"wrap_fn_ptr!(pub unsafe extern \"C\" fn mct(","highlight_start":1,"highlight_end":43},{"text":"    tmp: *mut i16,","highlight_start":1,"highlight_end":19},{"text":"    src_ptr: *const DynPixel,","highlight_start":1,"highlight_end":30},{"text":"    src_stride: isize,","highlight_start":1,"highlight_end":23},{"text":"    w: i32,","highlight_start":1,"highlight_end":12},{"text":"    h: i32,","highlight_start":1,"highlight_end":12},{"text":"    mx: i32,","highlight_start":1,"highlight_end":13},{"text":"    my: i32,","highlight_start":1,"highlight_end":13},{"text":"    bitdepth_max: i32,","highlight_start":1,"highlight_end":23},{"text":"    _src: *const FFISafe<Rav1dPictureDataComponentOffset>,","highlight_start":1,"highlight_end":59},{"text":") -> ());","highlight_start":1,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"wrap_fn_ptr!","def_site_span":{"file_name":"src/wrap_fn_ptr.rs","byte_start":1818,"byte_end":1842,"line_start":41,"line_end":41,"column_start":1,"column_end":25,"is_primary":false,"text":[{"text":"macro_rules! wrap_fn_ptr {","highlight_start":1,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"#[derive(PartialEq)]","def_site_span":{"file_name":"/rustc/f60a0f1bcc5a2a6dd8eb2d2021da79b40f5fbae9/library/core/src/cmp.rs","byte_start":10192,"byte_end":10211,"line_start":274,"line_end":274,"column_start":1,"column_end":20,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the address of the same function can vary between different codegen units","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"furthermore, different functions could have the same address after being merged together","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more information visit <https://doc.rust-lang.org/nightly/core/ptr/fn.fn_addr_eq.html>","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: function pointer comparisons do not produce meaningful results since their addresses are not guaranteed to be unique\u001b[0m\n    \u001b[1m\u001b[94m--> \u001b[0msrc/wrap_fn_ptr.rs:58:27\n     \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m  58\u001b[0m \u001b[1m\u001b[94m|\u001b[0m               pub struct Fn(FnPtr);\n     \u001b[1m\u001b[94m|\u001b[0m                             \u001b[1m\u001b[33m^^^^^\u001b[0m\n     \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m::: \u001b[0msrc/mc.rs:1163:1\n     \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m1163\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m wrap_fn_ptr!(pub unsafe extern \"C\" fn mct(\n\u001b[1m\u001b[94m1164\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     tmp: *mut i16,\n\u001b[1m\u001b[94m1165\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     src_ptr: *const DynPixel,\n\u001b[1m\u001b[94m1166\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     src_stride: isize,\n\u001b[1m\u001b[94m...\u001b[0m    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m1172\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     _src: *const FFISafe<Rav1dPictureDataComponentOffset>,\n\u001b[1m\u001b[94m1173\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m ) -> ());\n     \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|________-\u001b[0m \u001b[1m\u001b[94min this macro invocation\u001b[0m\n     \u001b[1m\u001b[94m|\u001b[0m\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the address of the same function can vary between different codegen units\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: furthermore, different functions could have the same address after being merged together\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for more information visit <https://doc.rust-lang.org/nightly/core/ptr/fn.fn_addr_eq.html>\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this warning originates in the derive macro `PartialEq` which comes from the expansion of the macro `wrap_fn_ptr` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"function pointer comparisons do not produce meaningful results since their addresses are not guaranteed to be unique","code":{"code":"unpredictable_function_pointer_comparisons","explanation":null},"level":"warning","spans":[{"file_name":"src/wrap_fn_ptr.rs","byte_start":2500,"byte_end":2505,"line_start":58,"line_end":58,"column_start":27,"column_end":32,"is_primary":true,"text":[{"text":"            pub struct Fn(FnPtr);","highlight_start":27,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/wrap_fn_ptr.rs","byte_start":2425,"byte_end":2434,"line_start":56,"line_end":56,"column_start":35,"column_end":44,"is_primary":false,"text":[{"text":"            #[derive(Clone, Copy, PartialEq, Eq)]","highlight_start":35,"highlight_end":44}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/mc.rs","byte_start":36285,"byte_end":36573,"line_start":1196,"line_end":1208,"column_start":1,"column_end":9,"is_primary":false,"text":[{"text":"wrap_fn_ptr!(pub unsafe extern \"C\" fn mct_scaled(","highlight_start":1,"highlight_end":50},{"text":"    tmp: *mut i16,","highlight_start":1,"highlight_end":19},{"text":"    src_ptr: *const DynPixel,","highlight_start":1,"highlight_end":30},{"text":"    src_stride: isize,","highlight_start":1,"highlight_end":23},{"text":"    w: i32,","highlight_start":1,"highlight_end":12},{"text":"    h: i32,","highlight_start":1,"highlight_end":12},{"text":"    mx: i32,","highlight_start":1,"highlight_end":13},{"text":"    my: i32,","highlight_start":1,"highlight_end":13},{"text":"    dx: i32,","highlight_start":1,"highlight_end":13},{"text":"    dy: i32,","highlight_start":1,"highlight_end":13},{"text":"    bitdepth_max: i32,","highlight_start":1,"highlight_end":23},{"text":"    _src: *const FFISafe<Rav1dPictureDataComponentOffset>,","highlight_start":1,"highlight_end":59},{"text":") -> ());","highlight_start":1,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"wrap_fn_ptr!","def_site_span":{"file_name":"src/wrap_fn_ptr.rs","byte_start":1818,"byte_end":1842,"line_start":41,"line_end":41,"column_start":1,"column_end":25,"is_primary":false,"text":[{"text":"macro_rules! wrap_fn_ptr {","highlight_start":1,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"#[derive(PartialEq)]","def_site_span":{"file_name":"/rustc/f60a0f1bcc5a2a6dd8eb2d2021da79b40f5fbae9/library/core/src/cmp.rs","byte_start":10192,"byte_end":10211,"line_start":274,"line_end":274,"column_start":1,"column_end":20,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the address of the same function can vary between different codegen units","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"furthermore, different functions could have the same address after being merged together","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more information visit <https://doc.rust-lang.org/nightly/core/ptr/fn.fn_addr_eq.html>","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: function pointer comparisons do not produce meaningful results since their addresses are not guaranteed to be unique\u001b[0m\n    \u001b[1m\u001b[94m--> \u001b[0msrc/wrap_fn_ptr.rs:58:27\n     \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m  58\u001b[0m \u001b[1m\u001b[94m|\u001b[0m               pub struct Fn(FnPtr);\n     \u001b[1m\u001b[94m|\u001b[0m                             \u001b[1m\u001b[33m^^^^^\u001b[0m\n     \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m::: \u001b[0msrc/mc.rs:1196:1\n     \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m1196\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m wrap_fn_ptr!(pub unsafe extern \"C\" fn mct_scaled(\n\u001b[1m\u001b[94m1197\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     tmp: *mut i16,\n\u001b[1m\u001b[94m1198\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     src_ptr: *const DynPixel,\n\u001b[1m\u001b[94m1199\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     src_stride: isize,\n\u001b[1m\u001b[94m...\u001b[0m    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m1207\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     _src: *const FFISafe<Rav1dPictureDataComponentOffset>,\n\u001b[1m\u001b[94m1208\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m ) -> ());\n     \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|________-\u001b[0m \u001b[1m\u001b[94min this macro invocation\u001b[0m\n     \u001b[1m\u001b[94m|\u001b[0m\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the address of the same function can vary between different codegen units\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: furthermore, different functions could have the same address after being merged together\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for more information visit <https://doc.rust-lang.org/nightly/core/ptr/fn.fn_addr_eq.html>\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this warning originates in the derive macro `PartialEq` which comes from the expansion of the macro `wrap_fn_ptr` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"function pointer comparisons do not produce meaningful results since their addresses are not guaranteed to be unique","code":{"code":"unpredictable_function_pointer_comparisons","explanation":null},"level":"warning","spans":[{"file_name":"src/wrap_fn_ptr.rs","byte_start":2500,"byte_end":2505,"line_start":58,"line_end":58,"column_start":27,"column_end":32,"is_primary":true,"text":[{"text":"            pub struct Fn(FnPtr);","highlight_start":27,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/wrap_fn_ptr.rs","byte_start":2425,"byte_end":2434,"line_start":56,"line_end":56,"column_start":35,"column_end":44,"is_primary":false,"text":[{"text":"            #[derive(Clone, Copy, PartialEq, Eq)]","highlight_start":35,"highlight_end":44}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/mc.rs","byte_start":37254,"byte_end":37555,"line_start":1233,"line_end":1244,"column_start":1,"column_end":9,"is_primary":false,"text":[{"text":"wrap_fn_ptr!(pub unsafe extern \"C\" fn warp8x8t(","highlight_start":1,"highlight_end":48},{"text":"    tmp: *mut i16,","highlight_start":1,"highlight_end":19},{"text":"    tmp_stride: usize,","highlight_start":1,"highlight_end":23},{"text":"    src_ptr: *const DynPixel,","highlight_start":1,"highlight_end":30},{"text":"    src_stride: isize,","highlight_start":1,"highlight_end":23},{"text":"    abcd: &[i16; 4],","highlight_start":1,"highlight_end":21},{"text":"    mx: i32,","highlight_start":1,"highlight_end":13},{"text":"    my: i32,","highlight_start":1,"highlight_end":13},{"text":"    bitdepth_max: i32,","highlight_start":1,"highlight_end":23},{"text":"    _tmp_len: usize,","highlight_start":1,"highlight_end":21},{"text":"    _src: *const FFISafe<Rav1dPictureDataComponentOffset>,","highlight_start":1,"highlight_end":59},{"text":") -> ());","highlight_start":1,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"wrap_fn_ptr!","def_site_span":{"file_name":"src/wrap_fn_ptr.rs","byte_start":1818,"byte_end":1842,"line_start":41,"line_end":41,"column_start":1,"column_end":25,"is_primary":false,"text":[{"text":"macro_rules! wrap_fn_ptr {","highlight_start":1,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"#[derive(PartialEq)]","def_site_span":{"file_name":"/rustc/f60a0f1bcc5a2a6dd8eb2d2021da79b40f5fbae9/library/core/src/cmp.rs","byte_start":10192,"byte_end":10211,"line_start":274,"line_end":274,"column_start":1,"column_end":20,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the address of the same function can vary between different codegen units","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"furthermore, different functions could have the same address after being merged together","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more information visit <https://doc.rust-lang.org/nightly/core/ptr/fn.fn_addr_eq.html>","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: function pointer comparisons do not produce meaningful results since their addresses are not guaranteed to be unique\u001b[0m\n    \u001b[1m\u001b[94m--> \u001b[0msrc/wrap_fn_ptr.rs:58:27\n     \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m  58\u001b[0m \u001b[1m\u001b[94m|\u001b[0m               pub struct Fn(FnPtr);\n     \u001b[1m\u001b[94m|\u001b[0m                             \u001b[1m\u001b[33m^^^^^\u001b[0m\n     \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m::: \u001b[0msrc/mc.rs:1233:1\n     \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m1233\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m wrap_fn_ptr!(pub unsafe extern \"C\" fn warp8x8t(\n\u001b[1m\u001b[94m1234\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     tmp: *mut i16,\n\u001b[1m\u001b[94m1235\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     tmp_stride: usize,\n\u001b[1m\u001b[94m1236\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     src_ptr: *const DynPixel,\n\u001b[1m\u001b[94m...\u001b[0m    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m1243\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     _src: *const FFISafe<Rav1dPictureDataComponentOffset>,\n\u001b[1m\u001b[94m1244\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m ) -> ());\n     \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|________-\u001b[0m \u001b[1m\u001b[94min this macro invocation\u001b[0m\n     \u001b[1m\u001b[94m|\u001b[0m\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the address of the same function can vary between different codegen units\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: furthermore, different functions could have the same address after being merged together\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for more information visit <https://doc.rust-lang.org/nightly/core/ptr/fn.fn_addr_eq.html>\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this warning originates in the derive macro `PartialEq` which comes from the expansion of the macro `wrap_fn_ptr` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"function pointer comparisons do not produce meaningful results since their addresses are not guaranteed to be unique","code":{"code":"unpredictable_function_pointer_comparisons","explanation":null},"level":"warning","spans":[{"file_name":"src/wrap_fn_ptr.rs","byte_start":2500,"byte_end":2505,"line_start":58,"line_end":58,"column_start":27,"column_end":32,"is_primary":true,"text":[{"text":"            pub struct Fn(FnPtr);","highlight_start":27,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/wrap_fn_ptr.rs","byte_start":2425,"byte_end":2434,"line_start":56,"line_end":56,"column_start":35,"column_end":44,"is_primary":false,"text":[{"text":"            #[derive(Clone, Copy, PartialEq, Eq)]","highlight_start":35,"highlight_end":44}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/mc.rs","byte_start":38286,"byte_end":38560,"line_start":1272,"line_end":1281,"column_start":1,"column_end":9,"is_primary":false,"text":[{"text":"wrap_fn_ptr!(pub unsafe extern \"C\" fn avg(","highlight_start":1,"highlight_end":43},{"text":"    dst_ptr: *mut DynPixel,","highlight_start":1,"highlight_end":28},{"text":"    dst_stride: isize,","highlight_start":1,"highlight_end":23},{"text":"    tmp1: &[i16; COMPINTER_LEN],","highlight_start":1,"highlight_end":33},{"text":"    tmp2: &[i16; COMPINTER_LEN],","highlight_start":1,"highlight_end":33},{"text":"    w: i32,","highlight_start":1,"highlight_end":12},{"text":"    h: i32,","highlight_start":1,"highlight_end":12},{"text":"    bitdepth_max: i32,","highlight_start":1,"highlight_end":23},{"text":"    _dst: *const FFISafe<Rav1dPictureDataComponentOffset>,","highlight_start":1,"highlight_end":59},{"text":") -> ());","highlight_start":1,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"wrap_fn_ptr!","def_site_span":{"file_name":"src/wrap_fn_ptr.rs","byte_start":1818,"byte_end":1842,"line_start":41,"line_end":41,"column_start":1,"column_end":25,"is_primary":false,"text":[{"text":"macro_rules! wrap_fn_ptr {","highlight_start":1,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"#[derive(PartialEq)]","def_site_span":{"file_name":"/rustc/f60a0f1bcc5a2a6dd8eb2d2021da79b40f5fbae9/library/core/src/cmp.rs","byte_start":10192,"byte_end":10211,"line_start":274,"line_end":274,"column_start":1,"column_end":20,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the address of the same function can vary between different codegen units","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"furthermore, different functions could have the same address after being merged together","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more information visit <https://doc.rust-lang.org/nightly/core/ptr/fn.fn_addr_eq.html>","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: function pointer comparisons do not produce meaningful results since their addresses are not guaranteed to be unique\u001b[0m\n    \u001b[1m\u001b[94m--> \u001b[0msrc/wrap_fn_ptr.rs:58:27\n     \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m  58\u001b[0m \u001b[1m\u001b[94m|\u001b[0m               pub struct Fn(FnPtr);\n     \u001b[1m\u001b[94m|\u001b[0m                             \u001b[1m\u001b[33m^^^^^\u001b[0m\n     \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m::: \u001b[0msrc/mc.rs:1272:1\n     \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m1272\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m wrap_fn_ptr!(pub unsafe extern \"C\" fn avg(\n\u001b[1m\u001b[94m1273\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     dst_ptr: *mut DynPixel,\n\u001b[1m\u001b[94m1274\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     dst_stride: isize,\n\u001b[1m\u001b[94m1275\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     tmp1: &[i16; COMPINTER_LEN],\n\u001b[1m\u001b[94m...\u001b[0m    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m1280\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     _dst: *const FFISafe<Rav1dPictureDataComponentOffset>,\n\u001b[1m\u001b[94m1281\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m ) -> ());\n     \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|________-\u001b[0m \u001b[1m\u001b[94min this macro invocation\u001b[0m\n     \u001b[1m\u001b[94m|\u001b[0m\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the address of the same function can vary between different codegen units\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: furthermore, different functions could have the same address after being merged together\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for more information visit <https://doc.rust-lang.org/nightly/core/ptr/fn.fn_addr_eq.html>\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this warning originates in the derive macro `PartialEq` which comes from the expansion of the macro `wrap_fn_ptr` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"function pointer comparisons do not produce meaningful results since their addresses are not guaranteed to be unique","code":{"code":"unpredictable_function_pointer_comparisons","explanation":null},"level":"warning","spans":[{"file_name":"src/wrap_fn_ptr.rs","byte_start":2500,"byte_end":2505,"line_start":58,"line_end":58,"column_start":27,"column_end":32,"is_primary":true,"text":[{"text":"            pub struct Fn(FnPtr);","highlight_start":27,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/wrap_fn_ptr.rs","byte_start":2425,"byte_end":2434,"line_start":56,"line_end":56,"column_start":35,"column_end":44,"is_primary":false,"text":[{"text":"            #[derive(Clone, Copy, PartialEq, Eq)]","highlight_start":35,"highlight_end":44}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/mc.rs","byte_start":39130,"byte_end":39423,"line_start":1302,"line_end":1312,"column_start":1,"column_end":9,"is_primary":false,"text":[{"text":"wrap_fn_ptr!(pub unsafe extern \"C\" fn w_avg(","highlight_start":1,"highlight_end":45},{"text":"    dst_ptr: *mut DynPixel,","highlight_start":1,"highlight_end":28},{"text":"    dst_stride: isize,","highlight_start":1,"highlight_end":23},{"text":"    tmp1: &[i16; COMPINTER_LEN],","highlight_start":1,"highlight_end":33},{"text":"    tmp2: &[i16; COMPINTER_LEN],","highlight_start":1,"highlight_end":33},{"text":"    w: i32,","highlight_start":1,"highlight_end":12},{"text":"    h: i32,","highlight_start":1,"highlight_end":12},{"text":"    weight: i32,","highlight_start":1,"highlight_end":17},{"text":"    bitdepth_max: i32,","highlight_start":1,"highlight_end":23},{"text":"    _dst: *const FFISafe<Rav1dPictureDataComponentOffset>,","highlight_start":1,"highlight_end":59},{"text":") -> ());","highlight_start":1,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"wrap_fn_ptr!","def_site_span":{"file_name":"src/wrap_fn_ptr.rs","byte_start":1818,"byte_end":1842,"line_start":41,"line_end":41,"column_start":1,"column_end":25,"is_primary":false,"text":[{"text":"macro_rules! wrap_fn_ptr {","highlight_start":1,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"#[derive(PartialEq)]","def_site_span":{"file_name":"/rustc/f60a0f1bcc5a2a6dd8eb2d2021da79b40f5fbae9/library/core/src/cmp.rs","byte_start":10192,"byte_end":10211,"line_start":274,"line_end":274,"column_start":1,"column_end":20,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the address of the same function can vary between different codegen units","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"furthermore, different functions could have the same address after being merged together","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more information visit <https://doc.rust-lang.org/nightly/core/ptr/fn.fn_addr_eq.html>","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: function pointer comparisons do not produce meaningful results since their addresses are not guaranteed to be unique\u001b[0m\n    \u001b[1m\u001b[94m--> \u001b[0msrc/wrap_fn_ptr.rs:58:27\n     \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m  58\u001b[0m \u001b[1m\u001b[94m|\u001b[0m               pub struct Fn(FnPtr);\n     \u001b[1m\u001b[94m|\u001b[0m                             \u001b[1m\u001b[33m^^^^^\u001b[0m\n     \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m::: \u001b[0msrc/mc.rs:1302:1\n     \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m1302\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m wrap_fn_ptr!(pub unsafe extern \"C\" fn w_avg(\n\u001b[1m\u001b[94m1303\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     dst_ptr: *mut DynPixel,\n\u001b[1m\u001b[94m1304\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     dst_stride: isize,\n\u001b[1m\u001b[94m1305\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     tmp1: &[i16; COMPINTER_LEN],\n\u001b[1m\u001b[94m...\u001b[0m    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m1311\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     _dst: *const FFISafe<Rav1dPictureDataComponentOffset>,\n\u001b[1m\u001b[94m1312\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m ) -> ());\n     \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|________-\u001b[0m \u001b[1m\u001b[94min this macro invocation\u001b[0m\n     \u001b[1m\u001b[94m|\u001b[0m\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the address of the same function can vary between different codegen units\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: furthermore, different functions could have the same address after being merged together\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for more information visit <https://doc.rust-lang.org/nightly/core/ptr/fn.fn_addr_eq.html>\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this warning originates in the derive macro `PartialEq` which comes from the expansion of the macro `wrap_fn_ptr` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"function pointer comparisons do not produce meaningful results since their addresses are not guaranteed to be unique","code":{"code":"unpredictable_function_pointer_comparisons","explanation":null},"level":"warning","spans":[{"file_name":"src/wrap_fn_ptr.rs","byte_start":2500,"byte_end":2505,"line_start":58,"line_end":58,"column_start":27,"column_end":32,"is_primary":true,"text":[{"text":"            pub struct Fn(FnPtr);","highlight_start":27,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/wrap_fn_ptr.rs","byte_start":2425,"byte_end":2434,"line_start":56,"line_end":56,"column_start":35,"column_end":44,"is_primary":false,"text":[{"text":"            #[derive(Clone, Copy, PartialEq, Eq)]","highlight_start":35,"highlight_end":44}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/mc.rs","byte_start":40026,"byte_end":40322,"line_start":1334,"line_end":1344,"column_start":1,"column_end":9,"is_primary":false,"text":[{"text":"wrap_fn_ptr!(pub unsafe extern \"C\" fn mask(","highlight_start":1,"highlight_end":44},{"text":"    dst_ptr: *mut DynPixel,","highlight_start":1,"highlight_end":28},{"text":"    dst_stride: isize,","highlight_start":1,"highlight_end":23},{"text":"    tmp1: &[i16; COMPINTER_LEN],","highlight_start":1,"highlight_end":33},{"text":"    tmp2: &[i16; COMPINTER_LEN],","highlight_start":1,"highlight_end":33},{"text":"    w: i32,","highlight_start":1,"highlight_end":12},{"text":"    h: i32,","highlight_start":1,"highlight_end":12},{"text":"    mask: *const u8,","highlight_start":1,"highlight_end":21},{"text":"    bitdepth_max: i32,","highlight_start":1,"highlight_end":23},{"text":"    _dst: *const FFISafe<Rav1dPictureDataComponentOffset>,","highlight_start":1,"highlight_end":59},{"text":") -> ());","highlight_start":1,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"wrap_fn_ptr!","def_site_span":{"file_name":"src/wrap_fn_ptr.rs","byte_start":1818,"byte_end":1842,"line_start":41,"line_end":41,"column_start":1,"column_end":25,"is_primary":false,"text":[{"text":"macro_rules! wrap_fn_ptr {","highlight_start":1,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"#[derive(PartialEq)]","def_site_span":{"file_name":"/rustc/f60a0f1bcc5a2a6dd8eb2d2021da79b40f5fbae9/library/core/src/cmp.rs","byte_start":10192,"byte_end":10211,"line_start":274,"line_end":274,"column_start":1,"column_end":20,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the address of the same function can vary between different codegen units","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"furthermore, different functions could have the same address after being merged together","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more information visit <https://doc.rust-lang.org/nightly/core/ptr/fn.fn_addr_eq.html>","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: function pointer comparisons do not produce meaningful results since their addresses are not guaranteed to be unique\u001b[0m\n    \u001b[1m\u001b[94m--> \u001b[0msrc/wrap_fn_ptr.rs:58:27\n     \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m  58\u001b[0m \u001b[1m\u001b[94m|\u001b[0m               pub struct Fn(FnPtr);\n     \u001b[1m\u001b[94m|\u001b[0m                             \u001b[1m\u001b[33m^^^^^\u001b[0m\n     \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m::: \u001b[0msrc/mc.rs:1334:1\n     \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m1334\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m wrap_fn_ptr!(pub unsafe extern \"C\" fn mask(\n\u001b[1m\u001b[94m1335\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     dst_ptr: *mut DynPixel,\n\u001b[1m\u001b[94m1336\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     dst_stride: isize,\n\u001b[1m\u001b[94m1337\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     tmp1: &[i16; COMPINTER_LEN],\n\u001b[1m\u001b[94m...\u001b[0m    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m1343\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     _dst: *const FFISafe<Rav1dPictureDataComponentOffset>,\n\u001b[1m\u001b[94m1344\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m ) -> ());\n     \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|________-\u001b[0m \u001b[1m\u001b[94min this macro invocation\u001b[0m\n     \u001b[1m\u001b[94m|\u001b[0m\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the address of the same function can vary between different codegen units\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: furthermore, different functions could have the same address after being merged together\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for more information visit <https://doc.rust-lang.org/nightly/core/ptr/fn.fn_addr_eq.html>\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this warning originates in the derive macro `PartialEq` which comes from the expansion of the macro `wrap_fn_ptr` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"function pointer comparisons do not produce meaningful results since their addresses are not guaranteed to be unique","code":{"code":"unpredictable_function_pointer_comparisons","explanation":null},"level":"warning","spans":[{"file_name":"src/wrap_fn_ptr.rs","byte_start":2500,"byte_end":2505,"line_start":58,"line_end":58,"column_start":27,"column_end":32,"is_primary":true,"text":[{"text":"            pub struct Fn(FnPtr);","highlight_start":27,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/wrap_fn_ptr.rs","byte_start":2425,"byte_end":2434,"line_start":56,"line_end":56,"column_start":35,"column_end":44,"is_primary":false,"text":[{"text":"            #[derive(Clone, Copy, PartialEq, Eq)]","highlight_start":35,"highlight_end":44}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/mc.rs","byte_start":40975,"byte_end":41302,"line_start":1367,"line_end":1378,"column_start":1,"column_end":9,"is_primary":false,"text":[{"text":"wrap_fn_ptr!(pub unsafe extern \"C\" fn w_mask(","highlight_start":1,"highlight_end":46},{"text":"    dst_ptr: *mut DynPixel,","highlight_start":1,"highlight_end":28},{"text":"    dst_stride: isize,","highlight_start":1,"highlight_end":23},{"text":"    tmp1: &[i16; COMPINTER_LEN],","highlight_start":1,"highlight_end":33},{"text":"    tmp2: &[i16; COMPINTER_LEN],","highlight_start":1,"highlight_end":33},{"text":"    w: i32,","highlight_start":1,"highlight_end":12},{"text":"    h: i32,","highlight_start":1,"highlight_end":12},{"text":"    mask: &mut [u8; SEG_MASK_LEN],","highlight_start":1,"highlight_end":35},{"text":"    sign: i32,","highlight_start":1,"highlight_end":15},{"text":"    bitdepth_max: i32,","highlight_start":1,"highlight_end":23},{"text":"    _dst: *const FFISafe<Rav1dPictureDataComponentOffset>,","highlight_start":1,"highlight_end":59},{"text":") -> ());","highlight_start":1,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"wrap_fn_ptr!","def_site_span":{"file_name":"src/wrap_fn_ptr.rs","byte_start":1818,"byte_end":1842,"line_start":41,"line_end":41,"column_start":1,"column_end":25,"is_primary":false,"text":[{"text":"macro_rules! wrap_fn_ptr {","highlight_start":1,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"#[derive(PartialEq)]","def_site_span":{"file_name":"/rustc/f60a0f1bcc5a2a6dd8eb2d2021da79b40f5fbae9/library/core/src/cmp.rs","byte_start":10192,"byte_end":10211,"line_start":274,"line_end":274,"column_start":1,"column_end":20,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the address of the same function can vary between different codegen units","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"furthermore, different functions could have the same address after being merged together","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more information visit <https://doc.rust-lang.org/nightly/core/ptr/fn.fn_addr_eq.html>","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: function pointer comparisons do not produce meaningful results since their addresses are not guaranteed to be unique\u001b[0m\n    \u001b[1m\u001b[94m--> \u001b[0msrc/wrap_fn_ptr.rs:58:27\n     \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m  58\u001b[0m \u001b[1m\u001b[94m|\u001b[0m               pub struct Fn(FnPtr);\n     \u001b[1m\u001b[94m|\u001b[0m                             \u001b[1m\u001b[33m^^^^^\u001b[0m\n     \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m::: \u001b[0msrc/mc.rs:1367:1\n     \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m1367\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m wrap_fn_ptr!(pub unsafe extern \"C\" fn w_mask(\n\u001b[1m\u001b[94m1368\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     dst_ptr: *mut DynPixel,\n\u001b[1m\u001b[94m1369\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     dst_stride: isize,\n\u001b[1m\u001b[94m1370\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     tmp1: &[i16; COMPINTER_LEN],\n\u001b[1m\u001b[94m...\u001b[0m    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m1377\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     _dst: *const FFISafe<Rav1dPictureDataComponentOffset>,\n\u001b[1m\u001b[94m1378\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m ) -> ());\n     \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|________-\u001b[0m \u001b[1m\u001b[94min this macro invocation\u001b[0m\n     \u001b[1m\u001b[94m|\u001b[0m\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the address of the same function can vary between different codegen units\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: furthermore, different functions could have the same address after being merged together\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for more information visit <https://doc.rust-lang.org/nightly/core/ptr/fn.fn_addr_eq.html>\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this warning originates in the derive macro `PartialEq` which comes from the expansion of the macro `wrap_fn_ptr` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"function pointer comparisons do not produce meaningful results since their addresses are not guaranteed to be unique","code":{"code":"unpredictable_function_pointer_comparisons","explanation":null},"level":"warning","spans":[{"file_name":"src/wrap_fn_ptr.rs","byte_start":2500,"byte_end":2505,"line_start":58,"line_end":58,"column_start":27,"column_end":32,"is_primary":true,"text":[{"text":"            pub struct Fn(FnPtr);","highlight_start":27,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/wrap_fn_ptr.rs","byte_start":2425,"byte_end":2434,"line_start":56,"line_end":56,"column_start":35,"column_end":44,"is_primary":false,"text":[{"text":"            #[derive(Clone, Copy, PartialEq, Eq)]","highlight_start":35,"highlight_end":44}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/mc.rs","byte_start":41948,"byte_end":42213,"line_start":1401,"line_end":1409,"column_start":1,"column_end":9,"is_primary":false,"text":[{"text":"wrap_fn_ptr!(pub unsafe extern \"C\" fn blend(","highlight_start":1,"highlight_end":45},{"text":"    dst_ptr: *mut DynPixel,","highlight_start":1,"highlight_end":28},{"text":"    dst_stride: isize,","highlight_start":1,"highlight_end":23},{"text":"    tmp: *const [DynPixel; SCRATCH_INTER_INTRA_BUF_LEN],","highlight_start":1,"highlight_end":57},{"text":"    w: i32,","highlight_start":1,"highlight_end":12},{"text":"    h: i32,","highlight_start":1,"highlight_end":12},{"text":"    mask: *const u8,","highlight_start":1,"highlight_end":21},{"text":"    _dst: *const FFISafe<Rav1dPictureDataComponentOffset>,","highlight_start":1,"highlight_end":59},{"text":") -> ());","highlight_start":1,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"wrap_fn_ptr!","def_site_span":{"file_name":"src/wrap_fn_ptr.rs","byte_start":1818,"byte_end":1842,"line_start":41,"line_end":41,"column_start":1,"column_end":25,"is_primary":false,"text":[{"text":"macro_rules! wrap_fn_ptr {","highlight_start":1,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"#[derive(PartialEq)]","def_site_span":{"file_name":"/rustc/f60a0f1bcc5a2a6dd8eb2d2021da79b40f5fbae9/library/core/src/cmp.rs","byte_start":10192,"byte_end":10211,"line_start":274,"line_end":274,"column_start":1,"column_end":20,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the address of the same function can vary between different codegen units","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"furthermore, different functions could have the same address after being merged together","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more information visit <https://doc.rust-lang.org/nightly/core/ptr/fn.fn_addr_eq.html>","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: function pointer comparisons do not produce meaningful results since their addresses are not guaranteed to be unique\u001b[0m\n    \u001b[1m\u001b[94m--> \u001b[0msrc/wrap_fn_ptr.rs:58:27\n     \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m  58\u001b[0m \u001b[1m\u001b[94m|\u001b[0m               pub struct Fn(FnPtr);\n     \u001b[1m\u001b[94m|\u001b[0m                             \u001b[1m\u001b[33m^^^^^\u001b[0m\n     \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m::: \u001b[0msrc/mc.rs:1401:1\n     \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m1401\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m wrap_fn_ptr!(pub unsafe extern \"C\" fn blend(\n\u001b[1m\u001b[94m1402\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     dst_ptr: *mut DynPixel,\n\u001b[1m\u001b[94m1403\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     dst_stride: isize,\n\u001b[1m\u001b[94m1404\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     tmp: *const [DynPixel; SCRATCH_INTER_INTRA_BUF_LEN],\n\u001b[1m\u001b[94m...\u001b[0m    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m1408\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     _dst: *const FFISafe<Rav1dPictureDataComponentOffset>,\n\u001b[1m\u001b[94m1409\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m ) -> ());\n     \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|________-\u001b[0m \u001b[1m\u001b[94min this macro invocation\u001b[0m\n     \u001b[1m\u001b[94m|\u001b[0m\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the address of the same function can vary between different codegen units\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: furthermore, different functions could have the same address after being merged together\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for more information visit <https://doc.rust-lang.org/nightly/core/ptr/fn.fn_addr_eq.html>\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this warning originates in the derive macro `PartialEq` which comes from the expansion of the macro `wrap_fn_ptr` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"function pointer comparisons do not produce meaningful results since their addresses are not guaranteed to be unique","code":{"code":"unpredictable_function_pointer_comparisons","explanation":null},"level":"warning","spans":[{"file_name":"src/wrap_fn_ptr.rs","byte_start":2500,"byte_end":2505,"line_start":58,"line_end":58,"column_start":27,"column_end":32,"is_primary":true,"text":[{"text":"            pub struct Fn(FnPtr);","highlight_start":27,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/wrap_fn_ptr.rs","byte_start":2425,"byte_end":2434,"line_start":56,"line_end":56,"column_start":35,"column_end":44,"is_primary":false,"text":[{"text":"            #[derive(Clone, Copy, PartialEq, Eq)]","highlight_start":35,"highlight_end":44}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/mc.rs","byte_start":42838,"byte_end":43074,"line_start":1430,"line_end":1437,"column_start":1,"column_end":9,"is_primary":false,"text":[{"text":"wrap_fn_ptr!(pub unsafe extern \"C\" fn blend_dir(","highlight_start":1,"highlight_end":49},{"text":"    dst_ptr: *mut DynPixel,","highlight_start":1,"highlight_end":28},{"text":"    dst_stride: isize,","highlight_start":1,"highlight_end":23},{"text":"    tmp: *const [DynPixel; SCRATCH_LAP_LEN],","highlight_start":1,"highlight_end":45},{"text":"    w: i32,","highlight_start":1,"highlight_end":12},{"text":"    h: i32,","highlight_start":1,"highlight_end":12},{"text":"    _dst: *const FFISafe<Rav1dPictureDataComponentOffset>,","highlight_start":1,"highlight_end":59},{"text":") -> ());","highlight_start":1,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"wrap_fn_ptr!","def_site_span":{"file_name":"src/wrap_fn_ptr.rs","byte_start":1818,"byte_end":1842,"line_start":41,"line_end":41,"column_start":1,"column_end":25,"is_primary":false,"text":[{"text":"macro_rules! wrap_fn_ptr {","highlight_start":1,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"#[derive(PartialEq)]","def_site_span":{"file_name":"/rustc/f60a0f1bcc5a2a6dd8eb2d2021da79b40f5fbae9/library/core/src/cmp.rs","byte_start":10192,"byte_end":10211,"line_start":274,"line_end":274,"column_start":1,"column_end":20,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the address of the same function can vary between different codegen units","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"furthermore, different functions could have the same address after being merged together","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more information visit <https://doc.rust-lang.org/nightly/core/ptr/fn.fn_addr_eq.html>","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: function pointer comparisons do not produce meaningful results since their addresses are not guaranteed to be unique\u001b[0m\n    \u001b[1m\u001b[94m--> \u001b[0msrc/wrap_fn_ptr.rs:58:27\n     \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m  58\u001b[0m \u001b[1m\u001b[94m|\u001b[0m               pub struct Fn(FnPtr);\n     \u001b[1m\u001b[94m|\u001b[0m                             \u001b[1m\u001b[33m^^^^^\u001b[0m\n     \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m::: \u001b[0msrc/mc.rs:1430:1\n     \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m1430\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m wrap_fn_ptr!(pub unsafe extern \"C\" fn blend_dir(\n\u001b[1m\u001b[94m1431\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     dst_ptr: *mut DynPixel,\n\u001b[1m\u001b[94m1432\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     dst_stride: isize,\n\u001b[1m\u001b[94m1433\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     tmp: *const [DynPixel; SCRATCH_LAP_LEN],\n\u001b[1m\u001b[94m...\u001b[0m    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m1436\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     _dst: *const FFISafe<Rav1dPictureDataComponentOffset>,\n\u001b[1m\u001b[94m1437\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m ) -> ());\n     \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|________-\u001b[0m \u001b[1m\u001b[94min this macro invocation\u001b[0m\n     \u001b[1m\u001b[94m|\u001b[0m\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the address of the same function can vary between different codegen units\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: furthermore, different functions could have the same address after being merged together\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for more information visit <https://doc.rust-lang.org/nightly/core/ptr/fn.fn_addr_eq.html>\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this warning originates in the derive macro `PartialEq` which comes from the expansion of the macro `wrap_fn_ptr` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"function pointer comparisons do not produce meaningful results since their addresses are not guaranteed to be unique","code":{"code":"unpredictable_function_pointer_comparisons","explanation":null},"level":"warning","spans":[{"file_name":"src/wrap_fn_ptr.rs","byte_start":2500,"byte_end":2505,"line_start":58,"line_end":58,"column_start":27,"column_end":32,"is_primary":true,"text":[{"text":"            pub struct Fn(FnPtr);","highlight_start":27,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/wrap_fn_ptr.rs","byte_start":2425,"byte_end":2434,"line_start":56,"line_end":56,"column_start":35,"column_end":44,"is_primary":false,"text":[{"text":"            #[derive(Clone, Copy, PartialEq, Eq)]","highlight_start":35,"highlight_end":44}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/mc.rs","byte_start":43617,"byte_end":43930,"line_start":1456,"line_end":1468,"column_start":1,"column_end":9,"is_primary":false,"text":[{"text":"wrap_fn_ptr!(pub unsafe extern \"C\" fn emu_edge(","highlight_start":1,"highlight_end":48},{"text":"    bw: isize,","highlight_start":1,"highlight_end":15},{"text":"    bh: isize,","highlight_start":1,"highlight_end":15},{"text":"    iw: isize,","highlight_start":1,"highlight_end":15},{"text":"    ih: isize,","highlight_start":1,"highlight_end":15},{"text":"    x: isize,","highlight_start":1,"highlight_end":14},{"text":"    y: isize,","highlight_start":1,"highlight_end":14},{"text":"    dst: *mut [DynPixel; EMU_EDGE_LEN],","highlight_start":1,"highlight_end":40},{"text":"    dst_stride: isize,","highlight_start":1,"highlight_end":23},{"text":"    src_ptr: *const DynPixel,","highlight_start":1,"highlight_end":30},{"text":"    src_stride: isize,","highlight_start":1,"highlight_end":23},{"text":"    _src: *const FFISafe<Rav1dPictureDataComponent>,","highlight_start":1,"highlight_end":53},{"text":") -> ());","highlight_start":1,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"wrap_fn_ptr!","def_site_span":{"file_name":"src/wrap_fn_ptr.rs","byte_start":1818,"byte_end":1842,"line_start":41,"line_end":41,"column_start":1,"column_end":25,"is_primary":false,"text":[{"text":"macro_rules! wrap_fn_ptr {","highlight_start":1,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"#[derive(PartialEq)]","def_site_span":{"file_name":"/rustc/f60a0f1bcc5a2a6dd8eb2d2021da79b40f5fbae9/library/core/src/cmp.rs","byte_start":10192,"byte_end":10211,"line_start":274,"line_end":274,"column_start":1,"column_end":20,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the address of the same function can vary between different codegen units","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"furthermore, different functions could have the same address after being merged together","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more information visit <https://doc.rust-lang.org/nightly/core/ptr/fn.fn_addr_eq.html>","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: function pointer comparisons do not produce meaningful results since their addresses are not guaranteed to be unique\u001b[0m\n    \u001b[1m\u001b[94m--> \u001b[0msrc/wrap_fn_ptr.rs:58:27\n     \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m  58\u001b[0m \u001b[1m\u001b[94m|\u001b[0m               pub struct Fn(FnPtr);\n     \u001b[1m\u001b[94m|\u001b[0m                             \u001b[1m\u001b[33m^^^^^\u001b[0m\n     \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m::: \u001b[0msrc/mc.rs:1456:1\n     \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m1456\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m wrap_fn_ptr!(pub unsafe extern \"C\" fn emu_edge(\n\u001b[1m\u001b[94m1457\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     bw: isize,\n\u001b[1m\u001b[94m1458\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     bh: isize,\n\u001b[1m\u001b[94m1459\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     iw: isize,\n\u001b[1m\u001b[94m...\u001b[0m    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m1467\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     _src: *const FFISafe<Rav1dPictureDataComponent>,\n\u001b[1m\u001b[94m1468\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m ) -> ());\n     \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|________-\u001b[0m \u001b[1m\u001b[94min this macro invocation\u001b[0m\n     \u001b[1m\u001b[94m|\u001b[0m\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the address of the same function can vary between different codegen units\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: furthermore, different functions could have the same address after being merged together\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for more information visit <https://doc.rust-lang.org/nightly/core/ptr/fn.fn_addr_eq.html>\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this warning originates in the derive macro `PartialEq` which comes from the expansion of the macro `wrap_fn_ptr` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"function pointer comparisons do not produce meaningful results since their addresses are not guaranteed to be unique","code":{"code":"unpredictable_function_pointer_comparisons","explanation":null},"level":"warning","spans":[{"file_name":"src/wrap_fn_ptr.rs","byte_start":2500,"byte_end":2505,"line_start":58,"line_end":58,"column_start":27,"column_end":32,"is_primary":true,"text":[{"text":"            pub struct Fn(FnPtr);","highlight_start":27,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/wrap_fn_ptr.rs","byte_start":2425,"byte_end":2434,"line_start":56,"line_end":56,"column_start":35,"column_end":44,"is_primary":false,"text":[{"text":"            #[derive(Clone, Copy, PartialEq, Eq)]","highlight_start":35,"highlight_end":44}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/mc.rs","byte_start":44733,"byte_end":45105,"line_start":1497,"line_end":1510,"column_start":1,"column_end":9,"is_primary":false,"text":[{"text":"wrap_fn_ptr!(pub unsafe extern \"C\" fn resize(","highlight_start":1,"highlight_end":46},{"text":"    dst: *mut DynPixel,","highlight_start":1,"highlight_end":24},{"text":"    dst_stride: isize,","highlight_start":1,"highlight_end":23},{"text":"    src_ptr: *const DynPixel,","highlight_start":1,"highlight_end":30},{"text":"    src_stride: isize,","highlight_start":1,"highlight_end":23},{"text":"    dst_w: i32,","highlight_start":1,"highlight_end":16},{"text":"    h: i32,","highlight_start":1,"highlight_end":12},{"text":"    src_w: i32,","highlight_start":1,"highlight_end":16},{"text":"    dx: i32,","highlight_start":1,"highlight_end":13},{"text":"    mx: i32,","highlight_start":1,"highlight_end":13},{"text":"    bitdepth_max: i32,","highlight_start":1,"highlight_end":23},{"text":"    _src: *const FFISafe<Rav1dPictureDataComponentOffset>,","highlight_start":1,"highlight_end":59},{"text":"    _dst: *const FFISafe<WithOffset<PicOrBuf<AlignedVec64<u8>>>>,","highlight_start":1,"highlight_end":66},{"text":") -> ());","highlight_start":1,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"wrap_fn_ptr!","def_site_span":{"file_name":"src/wrap_fn_ptr.rs","byte_start":1818,"byte_end":1842,"line_start":41,"line_end":41,"column_start":1,"column_end":25,"is_primary":false,"text":[{"text":"macro_rules! wrap_fn_ptr {","highlight_start":1,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"#[derive(PartialEq)]","def_site_span":{"file_name":"/rustc/f60a0f1bcc5a2a6dd8eb2d2021da79b40f5fbae9/library/core/src/cmp.rs","byte_start":10192,"byte_end":10211,"line_start":274,"line_end":274,"column_start":1,"column_end":20,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the address of the same function can vary between different codegen units","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"furthermore, different functions could have the same address after being merged together","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more information visit <https://doc.rust-lang.org/nightly/core/ptr/fn.fn_addr_eq.html>","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: function pointer comparisons do not produce meaningful results since their addresses are not guaranteed to be unique\u001b[0m\n    \u001b[1m\u001b[94m--> \u001b[0msrc/wrap_fn_ptr.rs:58:27\n     \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m  58\u001b[0m \u001b[1m\u001b[94m|\u001b[0m               pub struct Fn(FnPtr);\n     \u001b[1m\u001b[94m|\u001b[0m                             \u001b[1m\u001b[33m^^^^^\u001b[0m\n     \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m::: \u001b[0msrc/mc.rs:1497:1\n     \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m1497\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m wrap_fn_ptr!(pub unsafe extern \"C\" fn resize(\n\u001b[1m\u001b[94m1498\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     dst: *mut DynPixel,\n\u001b[1m\u001b[94m1499\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     dst_stride: isize,\n\u001b[1m\u001b[94m1500\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     src_ptr: *const DynPixel,\n\u001b[1m\u001b[94m...\u001b[0m    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m1509\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     _dst: *const FFISafe<WithOffset<PicOrBuf<AlignedVec64<u8>>>>,\n\u001b[1m\u001b[94m1510\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m ) -> ());\n     \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|________-\u001b[0m \u001b[1m\u001b[94min this macro invocation\u001b[0m\n     \u001b[1m\u001b[94m|\u001b[0m\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the address of the same function can vary between different codegen units\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: furthermore, different functions could have the same address after being merged together\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for more information visit <https://doc.rust-lang.org/nightly/core/ptr/fn.fn_addr_eq.html>\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this warning originates in the derive macro `PartialEq` which comes from the expansion of the macro `wrap_fn_ptr` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"function pointer comparisons do not produce meaningful results since their addresses are not guaranteed to be unique","code":{"code":"unpredictable_function_pointer_comparisons","explanation":null},"level":"warning","spans":[{"file_name":"src/wrap_fn_ptr.rs","byte_start":2500,"byte_end":2505,"line_start":58,"line_end":58,"column_start":27,"column_end":32,"is_primary":true,"text":[{"text":"            pub struct Fn(FnPtr);","highlight_start":27,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/wrap_fn_ptr.rs","byte_start":2425,"byte_end":2434,"line_start":56,"line_end":56,"column_start":35,"column_end":44,"is_primary":false,"text":[{"text":"            #[derive(Clone, Copy, PartialEq, Eq)]","highlight_start":35,"highlight_end":44}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/pal.rs","byte_start":145,"byte_end":303,"line_start":8,"line_end":15,"column_start":1,"column_end":9,"is_primary":false,"text":[{"text":"wrap_fn_ptr!(pub unsafe extern \"C\" fn pal_idx_finish(","highlight_start":1,"highlight_end":54},{"text":"    dst: *mut u8,","highlight_start":1,"highlight_end":18},{"text":"    src: *const u8,","highlight_start":1,"highlight_end":20},{"text":"    bw: c_int,","highlight_start":1,"highlight_end":15},{"text":"    bh: c_int,","highlight_start":1,"highlight_end":15},{"text":"    w: c_int,","highlight_start":1,"highlight_end":14},{"text":"    h: c_int,","highlight_start":1,"highlight_end":14},{"text":") -> ());","highlight_start":1,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"wrap_fn_ptr!","def_site_span":{"file_name":"src/wrap_fn_ptr.rs","byte_start":1818,"byte_end":1842,"line_start":41,"line_end":41,"column_start":1,"column_end":25,"is_primary":false,"text":[{"text":"macro_rules! wrap_fn_ptr {","highlight_start":1,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"#[derive(PartialEq)]","def_site_span":{"file_name":"/rustc/f60a0f1bcc5a2a6dd8eb2d2021da79b40f5fbae9/library/core/src/cmp.rs","byte_start":10192,"byte_end":10211,"line_start":274,"line_end":274,"column_start":1,"column_end":20,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the address of the same function can vary between different codegen units","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"furthermore, different functions could have the same address after being merged together","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more information visit <https://doc.rust-lang.org/nightly/core/ptr/fn.fn_addr_eq.html>","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: function pointer comparisons do not produce meaningful results since their addresses are not guaranteed to be unique\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/wrap_fn_ptr.rs:58:27\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m58\u001b[0m \u001b[1m\u001b[94m|\u001b[0m               pub struct Fn(FnPtr);\n   \u001b[1m\u001b[94m|\u001b[0m                             \u001b[1m\u001b[33m^^^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m::: \u001b[0msrc/pal.rs:8:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m wrap_fn_ptr!(pub unsafe extern \"C\" fn pal_idx_finish(\n\u001b[1m\u001b[94m 9\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     dst: *mut u8,\n\u001b[1m\u001b[94m10\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     src: *const u8,\n\u001b[1m\u001b[94m11\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     bw: c_int,\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m14\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     h: c_int,\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m ) -> ());\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|________-\u001b[0m \u001b[1m\u001b[94min this macro invocation\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the address of the same function can vary between different codegen units\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: furthermore, different functions could have the same address after being merged together\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for more information visit <https://doc.rust-lang.org/nightly/core/ptr/fn.fn_addr_eq.html>\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this warning originates in the derive macro `PartialEq` which comes from the expansion of the macro `wrap_fn_ptr` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"function pointer comparisons do not produce meaningful results since their addresses are not guaranteed to be unique","code":{"code":"unpredictable_function_pointer_comparisons","explanation":null},"level":"warning","spans":[{"file_name":"src/wrap_fn_ptr.rs","byte_start":2500,"byte_end":2505,"line_start":58,"line_end":58,"column_start":27,"column_end":32,"is_primary":true,"text":[{"text":"            pub struct Fn(FnPtr);","highlight_start":27,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/wrap_fn_ptr.rs","byte_start":2425,"byte_end":2434,"line_start":56,"line_end":56,"column_start":35,"column_end":44,"is_primary":false,"text":[{"text":"            #[derive(Clone, Copy, PartialEq, Eq)]","highlight_start":35,"highlight_end":44}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/refmvs.rs","byte_start":5095,"byte_end":5449,"line_start":177,"line_end":186,"column_start":1,"column_end":9,"is_primary":false,"text":[{"text":"wrap_fn_ptr!(pub(crate) unsafe extern \"C\" fn load_tmvs(","highlight_start":1,"highlight_end":56},{"text":"    rf: &AsmRefMvsFrame,","highlight_start":1,"highlight_end":25},{"text":"    tile_row_idx: i32,","highlight_start":1,"highlight_end":23},{"text":"    col_start8: i32,","highlight_start":1,"highlight_end":21},{"text":"    col_end8: i32,","highlight_start":1,"highlight_end":19},{"text":"    row_start8: i32,","highlight_start":1,"highlight_end":21},{"text":"    row_end8: i32,","highlight_start":1,"highlight_end":19},{"text":"    _rp_proj: *const FFISafe<DisjointMut<AlignedVec64<RefMvsTemporalBlock>>>,","highlight_start":1,"highlight_end":78},{"text":"    _rp_ref: *const FFISafe<[Option<DisjointMutArcSlice<RefMvsTemporalBlock>>; 7]>,","highlight_start":1,"highlight_end":84},{"text":") -> ());","highlight_start":1,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"wrap_fn_ptr!","def_site_span":{"file_name":"src/wrap_fn_ptr.rs","byte_start":1818,"byte_end":1842,"line_start":41,"line_end":41,"column_start":1,"column_end":25,"is_primary":false,"text":[{"text":"macro_rules! wrap_fn_ptr {","highlight_start":1,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"#[derive(PartialEq)]","def_site_span":{"file_name":"/rustc/f60a0f1bcc5a2a6dd8eb2d2021da79b40f5fbae9/library/core/src/cmp.rs","byte_start":10192,"byte_end":10211,"line_start":274,"line_end":274,"column_start":1,"column_end":20,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the address of the same function can vary between different codegen units","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"furthermore, different functions could have the same address after being merged together","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more information visit <https://doc.rust-lang.org/nightly/core/ptr/fn.fn_addr_eq.html>","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: function pointer comparisons do not produce meaningful results since their addresses are not guaranteed to be unique\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/wrap_fn_ptr.rs:58:27\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 58\u001b[0m \u001b[1m\u001b[94m|\u001b[0m               pub struct Fn(FnPtr);\n    \u001b[1m\u001b[94m|\u001b[0m                             \u001b[1m\u001b[33m^^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/refmvs.rs:177:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m177\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m wrap_fn_ptr!(pub(crate) unsafe extern \"C\" fn load_tmvs(\n\u001b[1m\u001b[94m178\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     rf: &AsmRefMvsFrame,\n\u001b[1m\u001b[94m179\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     tile_row_idx: i32,\n\u001b[1m\u001b[94m180\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     col_start8: i32,\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m185\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     _rp_ref: *const FFISafe<[Option<DisjointMutArcSlice<RefMvsTemporalBlock>>; 7]>,\n\u001b[1m\u001b[94m186\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m ) -> ());\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|________-\u001b[0m \u001b[1m\u001b[94min this macro invocation\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the address of the same function can vary between different codegen units\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: furthermore, different functions could have the same address after being merged together\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for more information visit <https://doc.rust-lang.org/nightly/core/ptr/fn.fn_addr_eq.html>\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this warning originates in the derive macro `PartialEq` which comes from the expansion of the macro `wrap_fn_ptr` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"function pointer comparisons do not produce meaningful results since their addresses are not guaranteed to be unique","code":{"code":"unpredictable_function_pointer_comparisons","explanation":null},"level":"warning","spans":[{"file_name":"src/wrap_fn_ptr.rs","byte_start":2500,"byte_end":2505,"line_start":58,"line_end":58,"column_start":27,"column_end":32,"is_primary":true,"text":[{"text":"            pub struct Fn(FnPtr);","highlight_start":27,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/wrap_fn_ptr.rs","byte_start":2425,"byte_end":2434,"line_start":56,"line_end":56,"column_start":35,"column_end":44,"is_primary":false,"text":[{"text":"            #[derive(Clone, Copy, PartialEq, Eq)]","highlight_start":35,"highlight_end":44}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/refmvs.rs","byte_start":7990,"byte_end":8397,"line_start":276,"line_end":288,"column_start":1,"column_end":9,"is_primary":false,"text":[{"text":"wrap_fn_ptr!(pub unsafe extern \"C\" fn save_tmvs(","highlight_start":1,"highlight_end":49},{"text":"    rp_ptr: *mut RefMvsTemporalBlock,","highlight_start":1,"highlight_end":38},{"text":"    stride: isize,","highlight_start":1,"highlight_end":19},{"text":"    rr: &[*const RefMvsBlock; 31],","highlight_start":1,"highlight_end":35},{"text":"    ref_sign: &[u8; 7],","highlight_start":1,"highlight_end":24},{"text":"    col_end8: i32,","highlight_start":1,"highlight_end":19},{"text":"    row_end8: i32,","highlight_start":1,"highlight_end":19},{"text":"    col_start8: i32,","highlight_start":1,"highlight_end":21},{"text":"    row_start8: i32,","highlight_start":1,"highlight_end":21},{"text":"    _r: *const FFISafe<DisjointMut<AlignedVec64<RefMvsBlock>>>,","highlight_start":1,"highlight_end":64},{"text":"    _ri: &[usize; 31],","highlight_start":1,"highlight_end":23},{"text":"    _rp: *const FFISafe<DisjointMutArcSlice<RefMvsTemporalBlock>>,","highlight_start":1,"highlight_end":67},{"text":") -> ());","highlight_start":1,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"wrap_fn_ptr!","def_site_span":{"file_name":"src/wrap_fn_ptr.rs","byte_start":1818,"byte_end":1842,"line_start":41,"line_end":41,"column_start":1,"column_end":25,"is_primary":false,"text":[{"text":"macro_rules! wrap_fn_ptr {","highlight_start":1,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"#[derive(PartialEq)]","def_site_span":{"file_name":"/rustc/f60a0f1bcc5a2a6dd8eb2d2021da79b40f5fbae9/library/core/src/cmp.rs","byte_start":10192,"byte_end":10211,"line_start":274,"line_end":274,"column_start":1,"column_end":20,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the address of the same function can vary between different codegen units","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"furthermore, different functions could have the same address after being merged together","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more information visit <https://doc.rust-lang.org/nightly/core/ptr/fn.fn_addr_eq.html>","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: function pointer comparisons do not produce meaningful results since their addresses are not guaranteed to be unique\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/wrap_fn_ptr.rs:58:27\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 58\u001b[0m \u001b[1m\u001b[94m|\u001b[0m               pub struct Fn(FnPtr);\n    \u001b[1m\u001b[94m|\u001b[0m                             \u001b[1m\u001b[33m^^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/refmvs.rs:276:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m276\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m wrap_fn_ptr!(pub unsafe extern \"C\" fn save_tmvs(\n\u001b[1m\u001b[94m277\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     rp_ptr: *mut RefMvsTemporalBlock,\n\u001b[1m\u001b[94m278\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     stride: isize,\n\u001b[1m\u001b[94m279\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     rr: &[*const RefMvsBlock; 31],\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m287\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     _rp: *const FFISafe<DisjointMutArcSlice<RefMvsTemporalBlock>>,\n\u001b[1m\u001b[94m288\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m ) -> ());\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|________-\u001b[0m \u001b[1m\u001b[94min this macro invocation\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the address of the same function can vary between different codegen units\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: furthermore, different functions could have the same address after being merged together\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for more information visit <https://doc.rust-lang.org/nightly/core/ptr/fn.fn_addr_eq.html>\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this warning originates in the derive macro `PartialEq` which comes from the expansion of the macro `wrap_fn_ptr` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"function pointer comparisons do not produce meaningful results since their addresses are not guaranteed to be unique","code":{"code":"unpredictable_function_pointer_comparisons","explanation":null},"level":"warning","spans":[{"file_name":"src/wrap_fn_ptr.rs","byte_start":2500,"byte_end":2505,"line_start":58,"line_end":58,"column_start":27,"column_end":32,"is_primary":true,"text":[{"text":"            pub struct Fn(FnPtr);","highlight_start":27,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/wrap_fn_ptr.rs","byte_start":2425,"byte_end":2434,"line_start":56,"line_end":56,"column_start":35,"column_end":44,"is_primary":false,"text":[{"text":"            #[derive(Clone, Copy, PartialEq, Eq)]","highlight_start":35,"highlight_end":44}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/refmvs.rs","byte_start":11388,"byte_end":11549,"line_start":358,"line_end":364,"column_start":1,"column_end":9,"is_primary":false,"text":[{"text":"wrap_fn_ptr!(pub unsafe extern \"C\" fn splat_mv(","highlight_start":1,"highlight_end":48},{"text":"    rr: *mut *mut RefMvsBlock,","highlight_start":1,"highlight_end":31},{"text":"    rmv: &Align16<RefMvsBlock>,","highlight_start":1,"highlight_end":32},{"text":"    bx4: i32,","highlight_start":1,"highlight_end":14},{"text":"    bw4: i32,","highlight_start":1,"highlight_end":14},{"text":"    bh4: i32,","highlight_start":1,"highlight_end":14},{"text":") -> ());","highlight_start":1,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"wrap_fn_ptr!","def_site_span":{"file_name":"src/wrap_fn_ptr.rs","byte_start":1818,"byte_end":1842,"line_start":41,"line_end":41,"column_start":1,"column_end":25,"is_primary":false,"text":[{"text":"macro_rules! wrap_fn_ptr {","highlight_start":1,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"#[derive(PartialEq)]","def_site_span":{"file_name":"/rustc/f60a0f1bcc5a2a6dd8eb2d2021da79b40f5fbae9/library/core/src/cmp.rs","byte_start":10192,"byte_end":10211,"line_start":274,"line_end":274,"column_start":1,"column_end":20,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the address of the same function can vary between different codegen units","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"furthermore, different functions could have the same address after being merged together","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more information visit <https://doc.rust-lang.org/nightly/core/ptr/fn.fn_addr_eq.html>","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: function pointer comparisons do not produce meaningful results since their addresses are not guaranteed to be unique\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/wrap_fn_ptr.rs:58:27\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 58\u001b[0m \u001b[1m\u001b[94m|\u001b[0m               pub struct Fn(FnPtr);\n    \u001b[1m\u001b[94m|\u001b[0m                             \u001b[1m\u001b[33m^^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/refmvs.rs:358:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m358\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m wrap_fn_ptr!(pub unsafe extern \"C\" fn splat_mv(\n\u001b[1m\u001b[94m359\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     rr: *mut *mut RefMvsBlock,\n\u001b[1m\u001b[94m360\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     rmv: &Align16<RefMvsBlock>,\n\u001b[1m\u001b[94m361\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     bx4: i32,\n\u001b[1m\u001b[94m362\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     bw4: i32,\n\u001b[1m\u001b[94m363\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     bh4: i32,\n\u001b[1m\u001b[94m364\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m ) -> ());\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|________-\u001b[0m \u001b[1m\u001b[94min this macro invocation\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the address of the same function can vary between different codegen units\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: furthermore, different functions could have the same address after being merged together\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for more information visit <https://doc.rust-lang.org/nightly/core/ptr/fn.fn_addr_eq.html>\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this warning originates in the derive macro `PartialEq` which comes from the expansion of the macro `wrap_fn_ptr` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"68 warnings emitted","code":null,"level":"warning","spans":[],"children":[],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: 68 warnings emitted\u001b[0m\n\n"}
